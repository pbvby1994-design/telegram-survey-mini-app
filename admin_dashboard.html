<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Блокнот Агитатора | v2.5 (Фикс Auth)</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jost:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-heat/dist/leaflet-heat.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#007bff',
                        'secondary': '#6c757d',
                        'tma-bg': 'var(--tg-theme-bg-color, #ffffff)',
                        'tma-text': 'var(--tg-theme-text-color, #000000)',
                        'tma-hint': 'var(--tg-theme-hint-color, #999999)',
                        'tma-link': 'var(--tg-theme-link-color, #007bff)',
                        'tma-button': 'var(--tg-theme-button-color, #007bff)',
                        'tma-button-text': 'var(--tg-theme-button-text-color, #ffffff)',
                    },
                    fontFamily: {
                        sans: ['Jost', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    <style>
        :root {
            --tg-theme-bg-color: #ffffff;
            --tg-theme-text-color: #000000;
            --tg-theme-hint-color: #999999;
            --tg-theme-link-color: #007bff;
            --tg-theme-button-color: #007bff;
            --tg-theme-button-text-color: #ffffff;
        }

        body {
            background-color: var(--tg-theme-bg-color);
            color: var(--tg-theme-text-color);
            font-family: 'Jost', sans-serif;
            transition: background-color 0.3s, color 0.3s;
        }

        .input-field {
            background-color: var(--tg-theme-secondary-bg-color, #f4f4f5);
            color: var(--tg-theme-text-color);
            border: 1px solid var(--tg-theme-hint-color);
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: var(--tg-theme-button-color);
            color: var(--tg-theme-button-text-color);
            transition: background-color 0.3s;
        }
        
        .btn-primary:hover {
            background-color: color-mix(in srgb, var(--tg-theme-button-color) 80%, black);
        }

        .tab-btn {
            color: var(--tg-theme-hint-color);
            border-bottom: 2px solid transparent;
            transition: color 0.3s, border-bottom-color 0.3s;
        }

        .tab-btn.active {
            color: var(--tg-theme-link-color);
            border-bottom-color: var(--tg-theme-link-color);
        }

        .card {
            background-color: var(--tg-theme-secondary-bg-color, #f4f4f5);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        
        #map-container {
            height: 400px; 
            width: 100%;
            border-radius: 0.5rem;
            overflow: hidden;
            z-index: 10;
        }

        .leaflet-container {
            background-color: var(--tg-theme-secondary-bg-color, #f4f4f5) !important;
        }

        .tooltip-text {
            color: var(--tg-theme-text-color);
        }

        /* Адаптивный дизайн */
        @media (min-width: 768px) {
            .container {
                max-width: 800px;
            }
        }
    </style>
</head>
<body class="p-4 md:p-6 min-h-screen">
    <div class="container mx-auto">
        <h1 class="text-xl font-bold mb-4 text-center">Блокнот Агитатора <span id="auth-status" class="text-xs font-normal text-red-500">(Offline)</span></h1>

        <!-- Панель отладки/статуса -->
        <div class="card p-3 mb-4 text-xs rounded-lg shadow-md">
            <div class="flex flex-wrap justify-between">
                <p>Telegram ID: <span id="debugUserId" class="font-medium">...</span></p>
                <p>Админ: <span id="debugAdminStatus" class="font-medium">...</span></p>
                <p>Кэш: <span id="debugCacheStatus" class="font-medium">...</span></p>
            </div>
        </div>

        <!-- Навигация -->
        <div class="flex justify-around mb-6 border-b border-gray-300">
            <button class="tab-btn p-2 flex-1 text-center font-medium active" data-section="form" onclick="showSection('form')">
                <i data-lucide="edit-3" class="w-5 h-5 inline-block mr-1 align-middle"></i> Отчет
            </button>
            <button class="tab-btn p-2 flex-1 text-center font-medium" data-section="data" onclick="showSection('data')">
                <i data-lucide="database" class="w-5 h-5 inline-block mr-1 align-middle"></i> Данные
            </button>
            <button class="tab-btn p-2 flex-1 text-center font-medium" data-section="map" onclick="showSection('map')">
                <i data-lucide="map" class="w-5 h-5 inline-block mr-1 align-middle"></i> Карта
            </button>
        </div>

        <!-- 1. Секция ФОРМА ОТЧЕТА -->
        <section id="form-section" class="mb-8">
            <form id="reportForm" class="space-y-4 card p-4 rounded-xl">
                <div>
                    <label for="settlement" class="block text-sm font-medium mb-1">Поселение (Обязательно)</label>
                    <select id="settlement" name="settlement" required class="input-field w-full p-2 rounded-lg">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div>
                    <label for="address" class="block text-sm font-medium mb-1">Улица, адрес</label>
                    <input type="text" id="address" name="address" class="input-field w-full p-2 rounded-lg" placeholder="Например: Ленина 10">
                </div>
                <div>
                    <label for="sentiment" class="block text-sm font-medium mb-1">Настроение жильцов (Обязательно)</label>
                    <select id="sentiment" name="sentiment" required class="input-field w-full p-2 rounded-lg">
                        <option value="">Выберите настроение</option>
                        <option value="positive">Позитивное (за)</option>
                        <option value="neutral">Нейтральное (безразлично)</option>
                        <option value="negative">Негативное (против)</option>
                        <option value="unknown">Неизвестно (не удалось поговорить)</option>
                    </select>
                </div>
                <div>
                    <label for="comment" class="block text-sm font-medium mb-1">Комментарий (Опционально)</label>
                    <textarea id="comment" name="comment" rows="3" class="input-field w-full p-2 rounded-lg" placeholder="Кратко о проблемах, просьбах, или о чем говорили..."></textarea>
                </div>
                <button type="submit" class="btn-primary w-full p-3 font-semibold rounded-xl flex items-center justify-center">
                    <i data-lucide="send" class="w-5 h-5 mr-2"></i> Отправить Отчет
                </button>
            </form>
        </section>

        <!-- 2. Секция ДАННЫЕ (только для Админа) -->
        <section id="data-section" class="hidden">
            <div id="admin-data-view" class="space-y-4">
                <h2 class="text-lg font-semibold border-b pb-2 mb-4">Админ-панель Отчетов</h2>
                
                <div class="flex space-x-2 mb-4">
                    <button id="loadReportsBtn" onclick="fetchAndRenderReports()" class="btn-primary p-2 text-sm rounded-lg flex-1">
                        <i data-lucide="download" class="w-4 h-4 inline-block mr-1 align-middle"></i> Загрузить Онлайн
                    </button>
                    <button id="clearDataBtn" onclick="window.showAlert('Подтверждение', 'Вы уверены, что хотите удалить ВСЕ данные из базы Firestore?', () => clearAllData(), true)" class="bg-red-500 text-white p-2 text-sm rounded-lg flex-1 hover:bg-red-600">
                        <i data-lucide="trash-2" class="w-4 h-4 inline-block mr-1 align-middle"></i> Очистить Базу
                    </button>
                </div>

                <!-- Статистика -->
                <div id="report-stats" class="grid grid-cols-2 gap-2 text-sm mb-4">
                    <div class="card p-3 rounded-lg text-center">
                        <p class="font-bold text-xl text-tma-link" id="totalReports">0</p>
                        <p class="text-tma-hint">Отчетов всего</p>
                    </div>
                    <div class="card p-3 rounded-lg text-center">
                        <p class="font-bold text-xl text-green-500" id="positiveReports">0</p>
                        <p class="text-tma-hint">Позитив</p>
                    </div>
                    <div class="card p-3 rounded-lg text-center col-span-2">
                        <canvas id="sentimentChart"></canvas>
                    </div>
                </div>

                <!-- Список отчетов -->
                <div class="card p-4 rounded-xl">
                    <h3 class="font-semibold mb-3">Последние 10 Отчетов</h3>
                    <div id="reportsList" class="space-y-3">
                        <p class="text-tma-hint" id="loading-indicator">Загрузка данных...</p>
                        <!-- Reports will be inserted here -->
                    </div>
                </div>
            </div>
            <div id="non-admin-view" class="card p-6 text-center text-red-500 font-semibold rounded-xl hidden">
                Доступ ограничен. Только для администраторов.
            </div>
        </section>
        
        <!-- 3. Секция КАРТА (только для Админа) -->
        <section id="map-section" class="hidden">
            <h2 class="text-lg font-semibold border-b pb-2 mb-4">Карта Активности</h2>
            <div id="map-container">
                <!-- Карта Leaflet будет здесь -->
            </div>
            <div class="mt-4 card p-3 rounded-lg">
                <p class="text-sm text-tma-hint">На карте отображаются кластеры отчетов (синие/красные) и тепловая карта активности.</p>
            </div>
        </section>

        <!-- Модальное окно (Alert/Confirm) -->
        <div id="alert-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center p-4 z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-sm">
                <h3 id="alert-title" class="text-xl font-bold mb-3 text-tma-text">Уведомление</h3>
                <p id="alert-message" class="mb-4 text-tma-text"></p>
                <div class="flex justify-end space-x-3">
                    <button id="alert-cancel-btn" class="px-4 py-2 text-sm rounded-lg bg-secondary text-white hidden">Отмена</button>
                    <button id="alert-ok-btn" class="px-4 py-2 text-sm rounded-lg btn-primary">ОК</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js"; // 👈 ИМПОРТ AUTH
        import { getFirestore, collection, addDoc, getDocs, deleteDoc, doc, setDoc, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- КОНФИГУРАЦИЯ FIREBASE (ЗАМЕНИТЕ НА СВОИ КЛЮЧИ) ---
        const firebaseConfig = {
             // Здесь должны быть ваши ключи!
        };

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        const isTMA = typeof Telegram !== 'undefined' && Telegram.WebApp.initData;
        const app = firebaseConfig.projectId ? initializeApp(firebaseConfig) : null;
        const db = app ? getFirestore(app) : null;
        const auth = app ? getAuth(app) : null; // 👈 ИНИЦИАЛИЗАЦИЯ AUTH

        let userTelegramId = isTMA ? (new URLSearchParams(Telegram.WebApp.initData).get('user') ? JSON.parse(new URLSearchParams(Telegram.WebApp.initData).get('user')).id : null) : null;
        let isAdmin = false;
        let dataCache = JSON.parse(localStorage.getItem('reports_cache') || '[]');
        let chartInstance = null;
        let mapInstance = null;
        let markerClusterLayer = null;

        // --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ UI ---
        
        window.showAlert = (title, message, callback = null, isConfirm = false) => {
            const modal = document.getElementById('alert-modal');
            document.getElementById('alert-title').textContent = title;
            document.getElementById('alert-message').textContent = message;
            const okBtn = document.getElementById('alert-ok-btn');
            const cancelBtn = document.getElementById('alert-cancel-btn');

            okBtn.onclick = () => {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                if (callback) callback(true);
            };

            if (isConfirm) {
                cancelBtn.classList.remove('hidden');
                cancelBtn.onclick = () => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    if (callback) callback(false);
                };
            } else {
                cancelBtn.classList.add('hidden');
            }

            modal.classList.remove('hidden');
            modal.classList.add('flex');
        };

        window.showSection = (sectionName) => {
            document.querySelectorAll('section').forEach(s => s.classList.add('hidden'));
            document.getElementById(`${sectionName}-section`).classList.remove('hidden');
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.tab-btn[data-section="${sectionName}"]`).classList.add('active');

            if (sectionName === 'data' || sectionName === 'map') {
                if (isAdmin) {
                    document.getElementById('non-admin-view').classList.add('hidden');
                    document.getElementById('admin-data-view').classList.remove('hidden');
                    // Если это вкладка Админа, обновляем данные
                    if (dataCache.length === 0) {
                        fetchAndRenderReports(true); // Принудительная загрузка
                    } else {
                        renderLatestData(dataCache);
                        if (sectionName === 'map') generateMap(dataCache);
                    }
                } else {
                    document.getElementById('non-admin-view').classList.remove('hidden');
                    document.getElementById('admin-data-view').classList.add('hidden');
                }
            }
            if (sectionName === 'map' && isAdmin) {
                // Инициализация карты, если она еще не создана
                 if (!mapInstance) generateMap(dataCache);
                 else if (mapInstance) mapInstance.invalidateSize(); // Важно для Leaflet в скрытом блоке
            }
        };

        const updateOfflineStatus = (isOnline = false) => {
            const statusElement = document.getElementById('auth-status');
            const cacheStatusElement = document.getElementById('debugCacheStatus');

            if (isOnline) {
                statusElement.textContent = '(Онлайн, Auth OK)';
                statusElement.classList.remove('text-red-500', 'text-orange-500');
                statusElement.classList.add('text-green-500');
            } else if (app) {
                // Если Auth null, но приложение инициализировано
                statusElement.textContent = '(Offline, Auth Fail)';
                statusElement.classList.remove('text-green-500');
                statusElement.classList.add('text-red-500');
            } else {
                 statusElement.textContent = '(Firebase Missing)';
                 statusElement.classList.remove('text-green-500');
                 statusElement.classList.add('text-orange-500');
            }

            cacheStatusElement.textContent = `${dataCache.length} записей`;
        };

        const populateSettlements = async () => {
            const select = document.getElementById('settlement');
            select.innerHTML = '<option value="">Загрузка поселений...</option>';

            // В отличие от reports, settlements доступны для чтения всем аутентифицированным пользователям
            if (db && auth.currentUser) {
                try {
                    const settlementsRef = collection(db, "settlements");
                    const snapshot = await getDocs(settlementsRef);
                    
                    const settlements = snapshot.docs.map(doc => doc.data().name).sort();

                    select.innerHTML = '<option value="">Выберите поселение</option>';
                    settlements.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });

                } catch (e) {
                    console.error("Error loading settlements:", e);
                    select.innerHTML = '<option value="">Ошибка загрузки (Проверьте правила/Auth)</option>';
                }
            } else {
                select.innerHTML = '<option value="">Auth не пройдена или Firebase не настроен</option>';
            }
        };
        
        // --- АУТЕНТИФИКАЦИЯ FIREBASE (КРИТИЧЕСКИ ВАЖНО) ---
        
        const authenticateUser = async () => {
            if (!isTMA || !app || !userTelegramId) {
                console.warn('TMA или Firebase не готовы для аутентификации.');
                updateOfflineStatus();
                return;
            }

            // 1. Получение Custom Token от вашего Python-бота
            // В реальном приложении это должен быть безопасный AJAX-запрос к вашему бэкенду.
            // Предположим, что вы отправляете initData через fetch.
            
            const authData = Telegram.WebApp.initData;
            
            // Заглушка: Здесь должен быть реальный запрос к бэкенду!
            // Пример: const response = await fetch('YOUR_BOT_API_ENDPOINT/auth', { method: 'POST', body: authData });
            // Вместо этого мы используем встроенные в Canvas переменные, если они доступны
            // Здесь мы полагаемся на то, что бот должен предоставить токен
            
            let customToken = '';
            
            // ПРИМЕЧАНИЕ: В реальном TMA, токен генерируется ботом и передается
            // через URL или другим безопасным способом. Здесь используем заглушку,
            // предполагая, что вы замените это реальным запросом.
            // Для целей Canvas используем глобальную переменную, если она определена.
            if (typeof __initial_auth_token !== 'undefined') {
                 customToken = __initial_auth_token;
            } else {
                 // ВНИМАНИЕ: Без токена, пользователь будет анонимным, и все 
                 // правила, требующие Custom Claims, провалятся.
                 console.warn("Custom Auth Token не предоставлен. Попытка анонимного входа.");
            }

            try {
                if (customToken) {
                     // Вход с токеном, который может содержать claims (admin: true)
                    const userCredential = await signInWithCustomToken(auth, customToken);
                    
                    // Успешный вход. Получаем токен с claims.
                    const tokenResult = await userCredential.user.getIdTokenResult();
                    isAdmin = tokenResult.claims.admin === true;
                    
                    // Обновляем userTelegramId (становится Firebase UID)
                    userTelegramId = userCredential.user.uid;
                    
                    console.log('Firebase Auth Success. Is Admin:', isAdmin);
                }
            } catch (error) {
                console.error("Firebase Authentication Error:", error);
                window.showAlert('Ошибка Auth', 'Не удалось войти в Firebase. ' + error.message);
            }
            
            // Настраиваем слушателя состояния Auth для обновления UI
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    updateOfflineStatus(true); // Онлайн, аутентификация успешна
                    // Если админ, запускаем загрузку данных
                    if (isAdmin) fetchAndRenderReports(false);
                } else {
                    updateOfflineStatus(false); // Оффлайн / Нет аутентификации
                }
                
                // Обновляем отладочные поля после Auth
                document.getElementById('debugUserId').textContent = userTelegramId || 'Нет ID';
                document.getElementById('debugAdminStatus').textContent = isAdmin ? 'ДА' : 'НЕТ';
                
                // После успешного Auth, загружаем поселения
                populateSettlements();
            });

            // Возвращаем флаг, чтобы window.onload мог дождаться
            return auth.currentUser !== null;
        };

        // --- ОБРАБОТКА ФОРМЫ И ОТПРАВКА ---

        document.getElementById('reportForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!auth.currentUser) {
                showAlert('ВНИМАНИЕ', 'Вы не аутентифицированы. Подождите, пока Auth не станет "Online", или проверьте настройки Firebase/Бота.');
                return;
            }
            if (isTMA) Telegram.WebApp.MainButton.showProgress();

            const form = e.target;
            const data = {
                settlement: form.settlement.value,
                address: form.address.value,
                sentiment: form.sentiment.value,
                comment: form.comment.value || '',
                timestamp: new Date(),
                reporterId: userTelegramId, // Используем Firebase UID (который должен быть ID Telegram)
            };

            try {
                if (db) {
                    // Используем коллекцию 'reports'
                    const docRef = await addDoc(collection(db, "reports"), data);
                    showAlert('Отчет отправлен!', `Ваш отчет для ${data.settlement} сохранен в облаке.`);
                    form.reset();
                    // Обновляем данные на панели админа, если пользователь - админ
                    if (isAdmin) fetchAndRenderReports();
                } else {
                    // Если нет подключения к Firestore, сохраняем в локальный кеш
                    dataCache.push(data);
                    localStorage.setItem('reports_cache', JSON.stringify(dataCache));
                    showAlert('Сохранено локально', `Отчет для ${data.settlement} сохранен локально. Отправьте его, когда восстановится соединение.`);
                    form.reset();
                    updateOfflineStatus();
                }
            } catch (e) {
                console.error("Ошибка при отправке отчета:", e);
                // Если ошибка связана с недостаточными правами, сообщаем об этом
                if (e.code === 'permission-denied') {
                     showAlert('Ошибка доступа', 'Отказано в доступе. Проверьте правила Firebase и Auth статус.');
                } else {
                     showAlert('Ошибка', 'Произошла ошибка при сохранении: ' + e.message);
                }
            } finally {
                if (isTMA) Telegram.WebApp.MainButton.hideProgress();
            }
        });

        // --- УПРАВЛЕНИЕ ДАННЫМИ (АДМИН) ---

        const fetchAndRenderReports = async (forceReload = false) => {
            if (!db || !isAdmin) return;

            document.getElementById('loading-indicator').textContent = 'Загрузка данных...';

            if (isTMA) Telegram.WebApp.MainButton.showLoader();

            try {
                // Если не нужно принудительно обновлять, используем кеш
                if (!forceReload && dataCache.length > 0) {
                     renderLatestData(dataCache);
                     return;
                }
                
                // Загружаем все отчеты (или последние 1000 для оптимизации)
                const reportsRef = collection(db, "reports");
                // Сортируем по timestamp и ограничиваем, чтобы не перегружать
                const q = query(reportsRef, orderBy("timestamp", "desc"), limit(1000)); 
                const snapshot = await getDocs(q);
                
                const reports = snapshot.docs.map(doc => ({ 
                    id: doc.id,
                    ...doc.data(), 
                    timestamp: doc.data().timestamp.toDate() // Преобразование Firestore Timestamp
                }));

                dataCache = reports;
                localStorage.setItem('reports_cache', JSON.stringify(dataCache));
                updateOfflineStatus();
                renderLatestData(reports);
                generateMap(reports);

            } catch (e) {
                console.error("Error fetching reports:", e);
                showAlert('Ошибка загрузки', 'Не удалось загрузить отчеты: ' + e.message + '. Проверьте подключение и права админа.');
                document.getElementById('loading-indicator').textContent = 'Ошибка загрузки данных.';
            } finally {
                if (isTMA) Telegram.WebApp.MainButton.hideLoader();
            }
        };

        window.renderLatestData = (reports) => {
            const reportsList = document.getElementById('reportsList');
            reportsList.innerHTML = '';
            
            // Считаем статистику
            const total = reports.length;
            const positive = reports.filter(r => r.sentiment === 'positive').length;
            const negative = reports.filter(r => r.sentiment === 'negative').length;
            const neutral = reports.filter(r => r.sentiment === 'neutral').length;
            const unknown = reports.filter(r => r.sentiment === 'unknown').length;
            
            document.getElementById('totalReports').textContent = total;
            document.getElementById('positiveReports').textContent = positive;
            
            // Обновление графика
            if (chartInstance) chartInstance.destroy();
            const ctx = document.getElementById('sentimentChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Позитив', 'Нейтрально', 'Негатив', 'Неизвестно'],
                    datasets: [{
                        data: [positive, neutral, negative, unknown],
                        backgroundColor: ['#10b981', '#f59e0b', '#ef4444', '#6b7280'],
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: 'var(--tg-theme-text-color)'
                            }
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });


            // Отображение списка (только последние 10)
            const latest10 = reports.slice(0, 10);

            if (latest10.length === 0) {
                 reportsList.innerHTML = '<p class="text-tma-hint">Нет отчетов для отображения.</p>';
                 return;
            }

            latest10.forEach(report => {
                const date = report.timestamp ? report.timestamp.toLocaleDateString('ru-RU', { hour: '2-digit', minute: '2-digit' }) : 'Нет даты';
                let colorClass = '';
                switch (report.sentiment) {
                    case 'positive': colorClass = 'bg-green-100 text-green-700'; break;
                    case 'negative': colorClass = 'bg-red-100 text-red-700'; break;
                    case 'neutral': colorClass = 'bg-yellow-100 text-yellow-700'; break;
                    default: colorClass = 'bg-gray-100 text-gray-700';
                }

                const reportDiv = document.createElement('div');
                reportDiv.className = `p-3 rounded-lg border border-gray-200 ${colorClass}`;
                reportDiv.innerHTML = `
                    <p class="font-semibold">${report.settlement} (${report.address || 'Адрес не указан'})</p>
                    <p class="text-xs text-tma-hint">От: ${report.reporterId} &bull; ${date}</p>
                    <p class="mt-1 text-sm">${report.comment || 'Нет комментария'}</p>
                `;
                reportsList.appendChild(reportDiv);
            });
        };

        window.generateMap = (reports) => {
            if (!document.getElementById('map-section').classList.contains('hidden')) {
                const geoData = reports.filter(r => r.lat && r.lng).map(r => [r.lat, r.lng, r.sentiment === 'positive' ? 0.8 : (r.sentiment === 'negative' ? 1.0 : 0.4)]);
                const markerData = reports.filter(r => r.lat && r.lng);

                if (mapInstance) {
                    mapInstance.remove();
                    mapInstance = null;
                }

                const initialLat = markerData.length > 0 ? markerData[0].lat : 55.751244; // Москва
                const initialLng = markerData.length > 0 ? markerData[0].lng : 37.618423;

                mapInstance = L.map('map-container').setView([initialLat, initialLng], 6);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(mapInstance);

                // Тепловая карта
                L.heatLayer(geoData, { 
                    radius: 25, 
                    blur: 15, 
                    maxZoom: 17,
                    gradient: {0.0: 'blue', 0.5: 'lime', 1.0: 'red'}
                }).addTo(mapInstance);
                
                // Маркеры с кластеризацией
                markerClusterLayer = L.markerClusterGroup();

                markerData.forEach(r => {
                    let color = 'gray';
                    if (r.sentiment === 'positive') color = 'green';
                    else if (r.sentiment === 'negative') color = 'red';
                    else if (r.sentiment === 'neutral') color = 'blue';

                    const markerHtmlStyles = `
                        background-color: ${color};
                        width: 1.5rem;
                        height: 1.5rem;
                        display: block;
                        left: -0.75rem;
                        top: -0.75rem;
                        position: relative;
                        border-radius: 3rem 3rem 0;
                        transform: rotate(45deg);
                        border: 1px solid #FFFFFF
                    `;

                    const icon = L.divIcon({
                        className: "my-custom-pin",
                        iconAnchor: [0, 24],
                        popupAnchor: [0, -36],
                        html: `<span style="${markerHtmlStyles}" />`
                    });

                    const popupContent = `
                        <h4 class="font-bold text-tma-text">${r.settlement}</h4>
                        <p class="text-tma-text">Адрес: ${r.address || 'Не указан'}</p>
                        <p class="text-tma-text">Настроение: ${r.sentiment}</p>
                        <p class="text-tma-text">Комментарий: ${r.comment || 'Нет'}</p>
                        <p class="text-xs text-tma-hint">Отчет: ${r.timestamp.toLocaleDateString()}</p>
                    `;

                    const marker = L.marker([r.lat, r.lng], { icon: icon })
                        .bindPopup(popupContent);
                    
                    markerClusterLayer.addLayer(marker);
                });

                mapInstance.addLayer(markerClusterLayer);

                // Корректировка зума, если есть маркеры
                if (markerData.length > 0) {
                    mapInstance.fitBounds(markerClusterLayer.getBounds(), { padding: [50, 50] });
                }
            }
        };


        const clearAllData = async () => {
             if (!db || !isAdmin) {
                 showAlert('Ошибка', 'У вас нет прав администратора для этой операции.');
                 return false;
             }

             if (isTMA) Telegram.WebApp.MainButton.showLoader();

             const batchSize = 100;
             let deletedCount = 0;

             try {
                const reportsRef = collection(db, "reports");
                let q = query(reportsRef, limit(batchSize));
                
                let snapshot;
                do {
                    snapshot = await getDocs(q);
                    
                    if (snapshot.size === 0) break;

                    const batch = writeBatch(db); // Используем writeBatch
                    
                    snapshot.docs.forEach(doc => {
                        batch.delete(doc.ref);
                    });

                    await batch.commit();
                    deletedCount += snapshot.size;

                    // Установка нового запроса для следующей партии
                    q = query(reportsRef, limit(batchSize));

                } while (snapshot.size > 0);


                dataCache = []; // Очищаем локальный кеш после удаления
                updateOfflineStatus();
                showAlert('Успешно!', `Удалено ${deletedCount} записей. Данные Firestore очищены.`);

                if (isAdmin) fetchAndRenderReports();

                return true;

            } catch (e) {
                 console.error("Error deleting collection:", e);
                 showAlert('Ошибка', 'Произошла ошибка при удалении коллекции: ' + e.message);
                 return false;
            } finally {
                 if (isTMA) Telegram.WebApp.MainButton.hideProgress();
            }
        };


        // --- ИНИЦИАЛИЗАЦИЯ WEBAPP ---
        if (isTMA) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        // 🔑 Инициализация при загрузке (Ожидаем authenticateUser) - ИСПРАВЛЕНО
        window.onload = async () => {
            // 1. Сначала аутентификация для установки isAdmin и userTelegramId
            await authenticateUser(); // 👈 КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ
            
            // 2. Затем заполнение интерфейса
            populateSettlements(); 
            updateOfflineStatus();
            window.showSection('form');
            lucide.createIcons();

            // ОТЛАДКА: Повторное обновление полей, чтобы гарантировать актуальность
            document.getElementById('debugUserId').textContent = userTelegramId || 'Нет ID';
            document.getElementById('debugAdminStatus').textContent = isAdmin ? 'ДА' : 'НЕТ';

            if (!firebaseConfig.projectId) {
                window.showAlert('ВНИМАНИЕ', 'Необходимо вставить ключи конфигурации Firebase в код.');
            }
        };

        // Экспортируем функции для доступа из HTML
        window.authenticateUser = authenticateUser;
        window.fetchAndRenderReports = fetchAndRenderReports;
        window.renderLatestData = renderLatestData;
        window.generateMap = generateMap;
    </script>
</body>
</html>
