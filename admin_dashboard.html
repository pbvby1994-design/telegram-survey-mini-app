<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Блокнот Агитатора | v2.5 (Фикс Админа/ID/Онлайн)</title>

    <!-- Tailwind CSS, Lucide Icons, Chart.js, Leaflet.js, XLSX, Firebase -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jost:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-heat/dist/leaflet-heat.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <!-- Firebase SDKs - v9 compat for wider support -->
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>

    <style>
        body { font-family: 'Jost', sans-serif; }
        .tab-button.active { @apply border-b-2 border-indigo-500 font-semibold text-indigo-700; }
        .tab-button { @apply px-4 py-2 text-center text-gray-500 transition duration-150 ease-in-out; }
        .card { @apply bg-white p-4 rounded-xl shadow-lg border border-gray-100; }
        .input-group label { @apply block text-sm font-medium text-gray-700 mb-1; }
        .input-group input, .input-group select, .input-group textarea { @apply w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500; }
        #map { height: 600px; width: 100%; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .leaflet-popup-content-wrapper { border-radius: 0.5rem; }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">

    <!-- Секция Уведомлений (Alert/Toast) -->
    <div id="alertContainer" class="fixed top-0 left-0 right-0 p-4 z-50 pointer-events-none">
        <!-- Alerts will be inserted here -->
    </div>

    <!-- Общий контейнер приложения -->
    <div class="container mx-auto p-4 max-w-4xl">
        <h1 class="text-3xl font-bold text-gray-800 mb-1 flex items-center">
            <i data-lucide="notebook-pen" class="w-6 h-6 mr-2 text-indigo-600"></i>
            Блокнот Агитатора
        </h1>
        <p class="text-sm text-gray-500 mb-4">v2.5 (Фикс Админа/ID/Онлайн)</p>

        <!-- Статус и Отладочная информация (Для Администратора) -->
        <div class="card mb-6 p-3 bg-indigo-50 border-indigo-200">
            <div class="flex flex-wrap items-center justify-between text-sm">
                <div class="flex items-center space-x-2">
                    <span class="font-medium text-indigo-700">Статус:</span>
                    <span id="offlineStatus" class="font-medium flex items-center">
                        <i data-lucide="zap" class="w-4 h-4 mr-1 text-green-500 animate-pulse"></i>
                        Онлайн
                    </span>
                </div>
                <div class="flex flex-wrap text-xs text-indigo-600 space-x-3">
                    <span title="Ваш ID в Telegram">ID: <span id="debugUserId" class="font-bold text-indigo-800">Нет ID</span></span>
                    <span title="Ваше Имя">Имя: <span id="debugUserName" class="font-bold text-indigo-800">N/A</span></span>
                    <span title="Права Администратора">Админ: <span id="debugAdminStatus" class="font-bold text-indigo-800">НЕТ</span></span>
                </div>
            </div>
        </div>

        <!-- Кнопки-табы -->
        <div class="flex border-b border-gray-200 mb-6">
            <button id="formTab" class="tab-button active" onclick="showSection('form')">
                <i data-lucide="square-pen" class="w-4 h-4 inline-block mr-1"></i>
                Ввод Данных
            </button>
            <button id="reportsTab" class="tab-button hidden" onclick="showSection('reports')">
                <i data-lucide="bar-chart-3" class="w-4 h-4 inline-block mr-1"></i>
                Отчеты (Админ)
            </button>
            <button id="latestDataTab" class="tab-button" onclick="showSection('latestData')">
                <i data-lucide="list-checks" class="w-4 h-4 inline-block mr-1"></i>
                Последние Записи
            </button>
        </div>

        <!-- 1. Секция Ввод Данных -->
        <section id="form" class="space-y-6">
            <div class="card">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Основная информация</h2>
                <form id="agitatorForm" onsubmit="submitForm(event)" class="space-y-4">
                    <!-- Населенный пункт -->
                    <div class="input-group">
                        <label for="settlement">Населенный пункт</label>
                        <select id="settlement" required>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>

                    <div class="flex space-x-4">
                        <!-- Улица -->
                        <div class="input-group w-3/4">
                            <label for="street">Улица</label>
                            <input type="text" id="street" placeholder="Например, Ленина" required>
                        </div>
                        <!-- Дом -->
                        <div class="input-group w-1/4">
                            <label for="house">Дом</label>
                            <input type="text" id="house" placeholder="Например, 10А" required>
                        </div>
                    </div>

                    <!-- Квартира (необязательно) -->
                    <div class="input-group">
                        <label for="apartment">Квартира (необязательно)</label>
                        <input type="text" id="apartment" placeholder="Например, 5">
                    </div>

                    <!-- Действие -->
                    <div class="input-group">
                        <label for="action">Действие</label>
                        <select id="action" required>
                            <option value="">Выберите действие</option>
                            <option value="Визит">Визит (Не застали)</option>
                            <option value="Проведен опрос">Проведен опрос</option>
                            <option value="Оставлен материал">Оставлен материал</option>
                        </select>
                    </div>

                    <!-- Лояльность -->
                    <div class="input-group">
                        <label for="loyalty">Лояльность</label>
                        <select id="loyalty" required>
                            <option value="">Выберите уровень лояльности</option>
                            <option value="Нейтрален">Нейтрален</option>
                            <option value="Поддерживает">Поддерживает</option>
                            <option value="Против">Против</option>
                            <option value="Неизвестно">Неизвестно</option>
                        </select>
                    </div>

                    <!-- Требуется повторный визит -->
                    <div class="input-group flex items-center space-x-2 pt-2">
                        <input type="checkbox" id="requiresFollowup" class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                        <label for="requiresFollowup" class="mb-0">Требуется повторный визит</label>
                    </div>

                    <!-- Комментарий -->
                    <div class="input-group">
                        <label for="comment">Комментарий (ваши заметки)</label>
                        <textarea id="comment" rows="3" placeholder="Краткие, важные замечания..."></textarea>
                    </div>

                    <!-- Кнопка Отправки -->
                    <button type="submit" class="w-full bg-indigo-600 text-white p-3 rounded-xl font-semibold hover:bg-indigo-700 transition duration-150 shadow-md">
                        <i data-lucide="save" class="w-5 h-5 inline-block mr-2"></i>
                        Сохранить Запись
                    </button>
                </form>
            </div>

            <!-- Секция Управления Кешем -->
            <div class="card bg-orange-50 border-orange-200">
                <h2 class="text-xl font-semibold text-gray-700 mb-4 flex items-center">
                    <i data-lucide="server-off" class="w-5 h-5 mr-2 text-orange-500"></i>
                    Автономный режим (Кэш)
                </h2>
                <p class="text-sm text-gray-600 mb-4">
                    Ваши записи временно хранятся в кэше, если нет соединения. Нажмите "Отправить" для синхронизации, когда появится Интернет.
                </p>
                <div class="flex space-x-4">
                    <button onclick="syncData()" class="flex-1 bg-green-600 text-white p-3 rounded-xl font-semibold hover:bg-green-700 transition duration-150 shadow-md" id="syncButton">
                        <i data-lucide="upload" class="w-5 h-5 inline-block mr-2"></i>
                        Отправить данные (<span id="cacheCount">0</span>)
                    </button>
                    <button onclick="clearCache()" class="bg-gray-400 text-white p-3 rounded-xl font-semibold hover:bg-gray-500 transition duration-150 shadow-md">
                        <i data-lucide="trash-2" class="w-5 h-5 inline-block"></i>
                    </button>
                </div>
            </div>
        </section>

        <!-- 2. Секция Отчеты (Администратор) -->
        <section id="reports" class="hidden space-y-6">
            <div class="card bg-red-50 border-red-200" id="adminPanel">
                <h2 class="text-xl font-semibold text-red-700 mb-4 flex items-center">
                    <i data-lucide="shield-alert" class="w-5 h-5 mr-2 text-red-500"></i>
                    Панель Администратора
                </h2>
                <p class="text-sm text-gray-600 mb-4">
                    Доступно только пользователю с ID: <span class="font-bold text-red-800">541459471</span>
                </p>
                <button onclick="confirmClearDatabase()" class="w-full bg-red-600 text-white p-3 rounded-xl font-semibold hover:bg-red-700 transition duration-150 shadow-md">
                    <i data-lucide="flame" class="w-5 h-5 inline-block mr-2"></i>
                    ОЧИСТИТЬ ВСЕ ДАННЫЕ В БАЗЕ (DANGER!)
                </button>
            </div>

            <div class="card">
                <h2 class="text-xl font-semibold text-gray-700 mb-4 flex items-center">
                    <i data-lucide="area-chart" class="w-5 h-5 mr-2 text-indigo-500"></i>
                    Сводный Отчет
                </h2>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-blue-50 p-3 rounded-lg text-center shadow-inner">
                        <p class="text-sm text-gray-500">Всего записей</p>
                        <p class="text-2xl font-bold text-blue-700" id="statTotalCount">0</p>
                    </div>
                    <div class="bg-yellow-50 p-3 rounded-lg text-center shadow-inner">
                        <p class="text-sm text-gray-500">Уникальных агитаторов</p>
                        <p class="text-2xl font-bold text-yellow-700" id="statUniqueUsers">0</p>
                    </div>
                </div>

                <!-- График Лояльности -->
                <h3 class="text-lg font-medium text-gray-700 mb-2">Лояльность</h3>
                <canvas id="loyaltyChart" class="mb-6"></canvas>

                <!-- Карта -->
                <h3 class="text-lg font-medium text-gray-700 mb-2">Карта активности</h3>
                <div id="map" class="mb-6"></div>

                <!-- Кнопка Экспорта -->
                <button onclick="exportToXLSX()" class="w-full bg-indigo-600 text-white p-3 rounded-xl font-semibold hover:bg-indigo-700 transition duration-150 shadow-md">
                    <i data-lucide="file-spreadsheet" class="w-5 h-5 inline-block mr-2"></i>
                    Экспорт в XLSX
                </button>
            </div>
        </section>

        <!-- 3. Секция Последние Данные -->
        <section id="latestData" class="hidden space-y-6">
            <div class="card">
                <h2 class="text-xl font-semibold text-gray-700 mb-4 flex items-center">
                    <i data-lucide="history" class="w-5 h-5 mr-2 text-indigo-500"></i>
                    Последние 20 Записей
                </h2>
                <div id="latestDataTable" class="overflow-x-auto">
                    <!-- Data will be inserted here -->
                </div>
                <p class="text-sm text-gray-500 mt-4 text-center">
                    <span class="font-bold">Внимание:</span> Эти данные загружаются только из кэша (автономный режим). Для полных данных используйте "Отчеты".
                </p>
            </div>
        </section>

    </div>

    <!-- Модальное окно для подтверждения удаления -->
    <div id="confirmModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 z-50 hidden items-center justify-center">
        <div class="bg-white p-6 rounded-xl shadow-2xl max-w-sm w-full space-y-4">
            <h3 class="text-lg font-bold text-red-600 flex items-center">
                <i data-lucide="alert-triangle" class="w-5 h-5 mr-2"></i>
                Подтверждение Удаления
            </h3>
            <p class="text-gray-700">Вы уверены, что хотите **НАВСЕГДА** удалить все данные в базе? Это действие необратимо!</p>
            <p class="text-sm text-gray-500">Введите `УДАЛИТЬ` для подтверждения:</p>
            <input type="text" id="confirmDeleteInput" class="w-full p-2 border border-red-300 rounded-lg focus:ring-red-500 focus:border-red-500">
            <div class="flex justify-end space-x-3">
                <button onclick="document.getElementById('confirmModal').classList.add('hidden')" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">Отмена</button>
                <button onclick="clearDatabase()" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition" id="confirmDeleteButton">Удалить</button>
            </div>
        </div>
    </div>


    <script>
        // --- КОНФИГУРАЦИЯ FIREBASE (ВСТАВИТЬ СЮДА ВАШИ КЛЮЧИ) ---
        const firebaseConfig = {
            apiKey: "AIzaSyDVeRXO16KtIwoJQb4uHQuCsEv3xTLBGhI",
            authDomain: "agitator-notebook.firebaseapp.com",
            projectId: "agitator-notebook",
            storageBucket: "agitator-notebook.firebasestorage.app",
            messagingSenderId: "518555352011",
            appId: "1:518555352011:web:2b152d193d56a29774619d"
        };
        const COLLECTION_NAME = "reports"; // Название коллекции в Firestore

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И КОНСТАНТЫ ---
        const ADMIN_ID = 541459471; // 👈 ВАШЕ ID АДМИНИСТРАТОРА (Mikhail)
        const TMA_URL_PLACEHOLDER = 'https://t.me/your_bot_username/your_webapp_name'; // URL для заглушки

        let app = null;
        let db = null;
        let isTMA = window.Telegram && window.Telegram.WebApp;
        let userTelegramId = null;
        let userFirstName = 'N/A';
        let isAdmin = false;
        let dataCache = []; // Локальный кеш для офлайн-данных

        // --- УТИЛИТЫ ---

        /**
         * Отображает уведомление/тост вверху экрана.
         * @param {string} title - Заголовок.
         * @param {string} message - Сообщение.
         * @param {string} type - Тип: 'success', 'error', 'warning', 'info'.
         */
        function showAlert(title, message, type = 'info') {
            const container = document.getElementById('alertContainer');
            let colorClass = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500',
                info: 'bg-blue-500'
            }[type] || 'bg-gray-500';

            const alert = document.createElement('div');
            alert.className = `${colorClass} text-white p-3 rounded-xl shadow-lg mb-2 flex justify-between items-center transition-opacity duration-300 pointer-events-auto`;
            alert.innerHTML = `
                <div>
                    <strong class="font-bold">${title}:</strong>
                    <span>${message}</span>
                </div>
                <button onclick="this.parentElement.remove()" class="ml-4 opacity-75 hover:opacity-100">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            `;

            container.prepend(alert);
            lucide.createIcons(); // Обновляем иконки

            // Автоматическое удаление через 5 секунд
            setTimeout(() => {
                alert.classList.add('opacity-0');
                setTimeout(() => alert.remove(), 300);
            }, 5000);
        }

        /**
         * Переключает видимость секций и активность табов.
         * @param {string} sectionId - ID секции для отображения ('form', 'reports', 'latestData').
         */
        function showSection(sectionId) {
            ['form', 'reports', 'latestData'].forEach(id => {
                const section = document.getElementById(id);
                const tab = document.getElementById(id + 'Tab');
                if (section && tab) {
                    if (id === sectionId) {
                        section.classList.remove('hidden');
                        tab.classList.add('active');
                    } else {
                        section.classList.add('hidden');
                        tab.classList.remove('active');
                    }
                }
            });

            // Обновляем данные, специфичные для таба
            if (sectionId === 'latestData') {
                renderLatestData();
            } else if (sectionId === 'reports' && isAdmin) {
                fetchAndRenderReports();
            }
        }
        window.showSection = showSection; // Экспортируем для HTML

        /**
         * Обновляет статус офлайн-режима.
         */
        function updateOfflineStatus() {
            const statusElement = document.getElementById('offlineStatus');
            const cacheCountElement = document.getElementById('cacheCount');
            const syncButton = document.getElementById('syncButton');

            cacheCountElement.textContent = dataCache.length;

            // Скрываем/показываем кнопку синхронизации
            if (dataCache.length > 0) {
                syncButton.classList.remove('hidden');
                syncButton.innerHTML = `<i data-lucide="upload" class="w-5 h-5 inline-block mr-2"></i> Отправить данные (${dataCache.length})`;
                statusElement.innerHTML = `<i data-lucide="cloud-off" class="w-4 h-4 mr-1 text-orange-500"></i> Офлайн (${dataCache.length} зап.)`;
                statusElement.classList.remove('text-green-700');
                statusElement.classList.add('text-orange-700');
            } else {
                syncButton.classList.add('hidden');
                statusElement.innerHTML = `<i data-lucide="zap" class="w-4 h-4 mr-1 text-green-500 animate-pulse"></i> Онлайн`;
                statusElement.classList.remove('text-orange-700');
                statusElement.classList.add('text-green-700');
            }
            lucide.createIcons();
        }

        /**
         * Загружает данные из IndexedDB (кэш).
         */
        async function loadCache() {
            try {
                // Инициализируем localforage для нашей коллекции
                const cacheStore = localforage.createInstance({ name: 'agitator_data_cache', storeName: COLLECTION_NAME });
                dataCache = [];
                await cacheStore.iterate((value) => {
                    dataCache.push(value);
                });
                updateOfflineStatus();
                console.log(`Кэш загружен. Найдено ${dataCache.length} записей.`);
            } catch (e) {
                console.error("Ошибка при загрузке кэша:", e);
                showAlert('Ошибка', 'Не удалось загрузить локальный кэш.', 'error');
            }
        }

        // --- ЛОГИКА ФОРМЫ И СОХРАНЕНИЯ ---

        /**
         * Заполняет выпадающий список поселений.
         */
        function populateSettlements() {
            const settlements = [
                "Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург", "Казань" // Мок-данные
                // Вставьте сюда реальные населенные пункты
            ];
            const select = document.getElementById('settlement');
            select.innerHTML = '<option value="">Выберите населенный пункт</option>';
            settlements.forEach(s => {
                const option = document.createElement('option');
                option.value = s;
                option.textContent = s;
                select.appendChild(option);
            });
        }

        /**
         * Отправляет данные формы в кэш или Firestore.
         * @param {Event} event - Событие отправки формы.
         */
        async function submitForm(event) {
            event.preventDefault();

            if (isTMA) Telegram.WebApp.MainButton.showProgress();

            // 1. Сбор данных
            const formData = {
                timestamp: Date.now(),
                user_id: userTelegramId || 'anon_' + (isTMA ? Telegram.WebApp.initDataUnsafe.user.id : 'web_mock'), // Если ID нет, используем заглушку
                full_name: userFirstName, // Добавлено имя
                settlement: document.getElementById('settlement').value,
                street: document.getElementById('street').value.trim(),
                house: document.getElementById('house').value.trim(),
                apartment: document.getElementById('apartment').value.trim() || 'N/A',
                action: document.getElementById('action').value,
                loyalty: document.getElementById('loyalty').value,
                requires_followup: document.getElementById('requiresFollowup').checked,
                comment: document.getElementById('comment').value.trim(),
                location: window.currentLocation || null, // Используем текущее местоположение
            };

            // 2. Попытка синхронизации/сохранения
            let success = await saveToFirestore(formData);

            if (isTMA) Telegram.WebApp.MainButton.hideProgress();

            if (success) {
                showAlert('Успешно!', 'Данные отправлены в облако.', 'success');
                document.getElementById('agitatorForm').reset();
                if (isAdmin) fetchAndRenderReports(); // Обновляем отчеты сразу
            } else {
                await saveToCache(formData);
                showAlert('Внимание!', 'Нет соединения! Данные сохранены в кэше. Нажмите "Отправить" для синхронизации.', 'warning');
            }

            renderLatestData(); // Обновляем последние записи
        }

        /**
         * Сохраняет данные в Firestore.
         * @param {Object} data - Объект данных.
         * @returns {boolean} - true, если успешно, false при ошибке (нет соединения).
         */
        async function saveToFirestore(data) {
            if (!db) return false;
            try {
                // Используем addDoc для добавления документа с авто-генерируемым ID
                await firebase.firestore().collection(COLLECTION_NAME).add(data);
                return true;
            } catch (e) {
                console.warn("Ошибка при сохранении в Firestore (вероятно, нет соединения):", e);
                return false;
            }
        }

        /**
         * Сохраняет данные в IndexedDB (localforage).
         * @param {Object} data - Объект данных.
         */
        async function saveToCache(data) {
            try {
                const cacheStore = localforage.createInstance({ name: 'agitator_data_cache', storeName: COLLECTION_NAME });
                // Используем timestamp как ключ
                await cacheStore.setItem(data.timestamp.toString(), data);
                dataCache.push(data); // Добавляем в локальный массив
                updateOfflineStatus();
            } catch (e) {
                console.error("Ошибка при сохранении в кэш:", e);
                showAlert('Ошибка', 'Не удалось сохранить данные в локальный кэш.', 'error');
            }
        }

        /**
         * Синхронизирует данные из кэша с Firestore.
         */
        async function syncData() {
            if (dataCache.length === 0) {
                showAlert('Инфо', 'Кэш пуст, нечего отправлять.', 'info');
                return;
            }
            if (!db) {
                showAlert('Ошибка', 'Firebase не инициализирован. Попробуйте обновить страницу.', 'error');
                return;
            }

            if (isTMA) Telegram.WebApp.MainButton.showProgress();

            let successfulSyncs = 0;
            const cacheStore = localforage.createInstance({ name: 'agitator_data_cache', storeName: COLLECTION_NAME });
            const recordsToSync = [...dataCache]; // Копируем для итерации

            for (const record of recordsToSync) {
                try {
                    // Используем addDoc, как при обычной отправке
                    await firebase.firestore().collection(COLLECTION_NAME).add(record);
                    // Удаляем запись из кэша и локального массива только после успешной отправки
                    await cacheStore.removeItem(record.timestamp.toString());
                    dataCache = dataCache.filter(item => item.timestamp !== record.timestamp);
                    successfulSyncs++;
                } catch (e) {
                    // Если произошла ошибка (например, пропало соединение в процессе)
                    console.error("Ошибка синхронизации записи:", e);
                    showAlert('Внимание!', `Ошибка синхронизации. Отправлено ${successfulSyncs} из ${recordsToSync.length}. Попробуйте позже.`, 'warning');
                    break;
                }
            }

            if (isTMA) Telegram.WebApp.MainButton.hideProgress();

            updateOfflineStatus();
            renderLatestData();

            if (successfulSyncs > 0) {
                showAlert('Синхронизация!', `Успешно отправлено ${successfulSyncs} записей!`, 'success');
            }

            if (isAdmin) fetchAndRenderReports(); // Обновляем отчеты
        }

        /**
         * Очищает весь локальный кэш (IndexedDB).
         */
        async function clearCache() {
            try {
                const cacheStore = localforage.createInstance({ name: 'agitator_data_cache', storeName: COLLECTION_NAME });
                await cacheStore.clear();
                dataCache = [];
                updateOfflineStatus();
                renderLatestData();
                showAlert('Кэш очищен', 'Все несохраненные локальные данные удалены.', 'info');
            } catch (e) {
                console.error("Ошибка при очистке кэша:", e);
                showAlert('Ошибка', 'Не удалось очистить локальный кэш.', 'error');
            }
        }

        // --- ГЕОЛОКАЦИЯ ---

        /**
         * Получает текущее местоположение пользователя.
         */
        function getLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        window.currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                        showAlert('Геолокация', `Местоположение получено: ${window.currentLocation.latitude.toFixed(4)}, ${window.currentLocation.longitude.toFixed(4)}`, 'info');
                    },
                    (error) => {
                        console.error("Ошибка геолокации:", error);
                        window.currentLocation = null;
                        showAlert('Геолокация', 'Не удалось получить местоположение. Проверьте разрешения.', 'warning');
                    },
                    { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 }
                );
            } else {
                showAlert('Геолокация', 'Ваш браузер не поддерживает геолокацию.', 'warning');
                window.currentLocation = null;
            }
        }


        // --- ОТЧЕТЫ И ВИЗУАЛИЗАЦИЯ (АДМИН) ---

        let mapInstance = null; // Переменная для хранения экземпляра карты
        let mapData = []; // Кеш для данных карты

        /**
         * Генерирует и отображает тепловую карту активности.
         * @param {Array<Object>} data - Данные отчетов.
         */
        function generateMap(data) {
            const mapElement = document.getElementById('map');
            if (!mapElement) return;

            // Если карта уже существует, удаляем ее
            if (mapInstance) {
                mapInstance.remove();
            }

            // 1. Фильтруем данные для карты (только с геолокацией)
            mapData = data.filter(d => d.location && d.location.latitude && d.location.longitude);
            const latLngs = mapData.map(d => [d.location.latitude, d.location.longitude, 0.5]); // [lat, lng, intensity]

            // 2. Определяем центр карты
            let centerLat = 55.7558; // Москва
            let centerLng = 37.6173;
            let zoom = 5;

            if (mapData.length > 0) {
                // Если есть данные, находим средние координаты
                const avgLat = mapData.reduce((sum, d) => sum + d.location.latitude, 0) / mapData.length;
                const avgLng = mapData.reduce((sum, d) => sum + d.location.longitude, 0) / mapData.length;
                centerLat = avgLat;
                centerLng = avgLng;
                zoom = 10; // Приближаем, если есть данные
            }

            // 3. Инициализация карты
            mapInstance = L.map('map').setView([centerLat, centerLng], zoom);

            // Добавляем тайлы (OpenStreetMap)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(mapInstance);

            // 4. Добавляем кластеры для маркеров
            const markers = L.markerClusterGroup();

            mapData.forEach(d => {
                const marker = L.marker([d.location.latitude, d.location.longitude]);
                const popupContent = `
                    <div class="font-sans text-sm">
                        <strong class="text-indigo-600">${d.full_name || d.user_id}</strong>
                        <p class="mt-1">
                            <i data-lucide="map-pin" class="w-4 h-4 inline-block mr-1 text-gray-500"></i>
                            ${d.settlement}, ${d.street}, ${d.house}
                        </p>
                        <p>
                            <i data-lucide="hand-metal" class="w-4 h-4 inline-block mr-1 text-gray-500"></i>
                            ${d.action} / ${d.loyalty}
                        </p>
                        <p class="text-xs text-gray-500 mt-1">
                            ${new Date(d.timestamp).toLocaleString()}
                        </p>
                    </div>
                `;
                marker.bindPopup(popupContent);
                markers.addLayer(marker);
            });

            mapInstance.addLayer(markers);

            // 5. Добавляем тепловую карту
            L.heatLayer(latLngs, {
                radius: 25,
                blur: 15,
                maxZoom: 17,
                gradient: { 0.4: 'blue', 0.6: 'lime', 1.0: 'red' }
            }).addTo(mapInstance);

            // Перерисовка иконок Lucide после добавления маркеров
            mapInstance.on('popupopen', () => {
                lucide.createIcons();
            });
        }

        /**
         * Строит круговую диаграмму.
         * @param {string} canvasId - ID элемента canvas.
         * @param {Object} data - Данные для диаграммы.
         * @param {string} label - Заголовок набора данных.
         */
        function generatePieChart(canvasId, data, label) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            const existingChart = Chart.getChart(canvasId);
            if (existingChart) existingChart.destroy();

            const labels = Object.keys(data);
            const values = Object.values(data);
            const total = values.reduce((sum, val) => sum + val, 0);

            // Цветовая палитра для лояльности
            const colorMap = {
                'Поддерживает': '#10b981', // green-500
                'Нейтрален': '#f59e0b',    // amber-500
                'Против': '#ef4444',       // red-500
                'Неизвестно': '#9ca3af',   // gray-400
            };
            const colors = labels.map(l => colorMap[l] || '#3b82f6'); // blue-500 - дефолт

            const chartOptions = {
                responsive: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.parsed;
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${context.label}: ${value} (${percentage}%)`;
                            }
                        }
                    },
                    title: {
                        display: false,
                    }
                }
            };

            new Chart(ctx, {
                type: 'pie',
                data: { labels: labels, datasets: [{ label: label, data: values, backgroundColor: colors, borderColor: '#ffffff', borderWidth: 1 }] },
                options: chartOptions
            });
        }

        /**
         * Извлекает и отображает отчеты (доступно только админам).
         */
        async function fetchAndRenderReports() {
            if (!isAdmin || !db) return;
            if (isTMA) Telegram.WebApp.MainButton.showProgress();

            try {
                const snapshot = await firebase.firestore().collection(COLLECTION_NAME).get();
                const data = snapshot.docs.map(doc => doc.data());

                // 1. Статистика
                document.getElementById('statTotalCount').textContent = data.length;
                const uniqueUsers = new Set(data.map(d => d.user_id));
                document.getElementById('statUniqueUsers').textContent = uniqueUsers.size;

                // 2. График Лояльности
                const loyaltyCounts = data.reduce((acc, d) => {
                    acc[d.loyalty] = (acc[d.loyalty] || 0) + 1;
                    return acc;
                }, {});
                generatePieChart('loyaltyChart', loyaltyCounts, 'Лояльность');

                // 3. Карта
                generateMap(data);

            } catch (e) {
                console.error("Ошибка при получении отчетов:", e);
                showAlert('Ошибка', 'Не удалось загрузить отчеты из Firestore. Проверьте соединение.', 'error');
            } finally {
                if (isTMA) Telegram.WebApp.MainButton.hideProgress();
            }
        }

        /**
         * Отображает последние 20 записей из кэша.
         */
        function renderLatestData() {
            const tableContainer = document.getElementById('latestDataTable');
            if (dataCache.length === 0) {
                tableContainer.innerHTML = '<p class="text-center text-gray-500 p-4">Нет сохраненных данных в кэше. <br>Все данные синхронизированы.</p>';
                return;
            }

            // Сортируем по времени (от нового к старому)
            const latestData = [...dataCache].sort((a, b) => b.timestamp - a.timestamp).slice(0, 20);

            let tableHTML = `
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Время</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Адрес</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Лояльность</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Комментарий</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">
            `;

            latestData.forEach(d => {
                const date = new Date(d.timestamp).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
                const loyaltyColor = { 'Поддерживает': 'bg-green-100 text-green-800', 'Против': 'bg-red-100 text-red-800', 'Нейтрален': 'bg-yellow-100 text-yellow-800', 'Неизвестно': 'bg-gray-100 text-gray-800' }[d.loyalty] || 'bg-gray-100 text-gray-800';

                tableHTML += `
                    <tr class="hover:bg-gray-50">
                        <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${date}</td>
                        <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">${d.settlement}, ${d.street}, ${d.house}${d.apartment !== 'N/A' ? `, кв. ${d.apartment}` : ''}</td>
                        <td class="px-3 py-2 whitespace-nowrap">
                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${loyaltyColor}">${d.loyalty}</span>
                        </td>
                        <td class="px-3 py-2 text-sm text-gray-500 max-w-xs truncate">${d.comment || '—'}</td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            tableContainer.innerHTML = tableHTML;
        }

        // --- УДАЛЕНИЕ КОЛЛЕКЦИИ (DANGER!) ---

        /**
         * Показывает модальное окно для подтверждения удаления.
         */
        function confirmClearDatabase() {
            document.getElementById('confirmDeleteInput').value = '';
            document.getElementById('confirmModal').classList.remove('hidden');
            document.getElementById('confirmDeleteInput').focus();
        }

        /**
         * Выполняет удаление всех данных из коллекции Firestore.
         */
        async function clearDatabase() {
            const confirmInput = document.getElementById('confirmDeleteInput').value.trim();
            if (confirmInput !== 'УДАЛИТЬ') {
                showAlert('Ошибка', 'Неверное подтверждающее слово.', 'error');
                return;
            }

            document.getElementById('confirmModal').classList.add('hidden'); // Скрываем модальное окно

            if (!isAdmin) {
                showAlert('Ошибка', 'У вас нет прав администратора для этой операции.', 'error');
                return;
            }
            if (!db) {
                showAlert('Ошибка', 'Firebase не инициализирован.', 'error');
                return;
            }

            if (isTMA) Telegram.WebApp.MainButton.showProgress();

            try {
                 // ВНИМАНИЕ: В Firestore нет прямого метода для удаления коллекции.
                 // Это упрощенная реализация, которая удаляет только 1000 документов.
                 // Для продакшн-систем необходимо использовать серверную функцию (Cloud Function).
                 // Однако для данного примера это сработает.

                let deletedCount = 0;
                let batch = firebase.firestore().batch();
                let hasMore = true;

                while(hasMore) {
                    const snapshot = await firebase.firestore().collection(COLLECTION_NAME).limit(500).get(); // Удаляем партиями по 500
                    hasMore = snapshot.size > 0;
                    if (snapshot.size === 0) break;

                    snapshot.docs.forEach(doc => {
                        batch.delete(doc.ref);
                        deletedCount++;
                    });

                    await batch.commit();
                    batch = firebase.firestore().batch(); // Сбрасываем batch
                }

                // Очищаем локальный кэш
                await clearCache();
                dataCache = []; // Очищаем локальный кеш после удаления
                updateOfflineStatus();
                showAlert('Успешно!', `Удалено ${deletedCount} записей. Данные Firestore очищены.`);

                if (isAdmin) fetchAndRenderReports();

                return true;

            } catch (e) {
                 console.error("Error deleting collection:", e);
                 showAlert('Ошибка', 'Произошла ошибка при удалении коллекции: ' + e.message);
                 return false;
            } finally {
                 if (isTMA) Telegram.WebApp.MainButton.hideProgress();
            }
        };


        // --- ИНИЦИАЛИЗАЦИЯ И АУТЕНТИФИКАЦИЯ ---

        /**
         * Инициализирует Firebase и устанавливает статус администратора.
         */
        async function authenticateUser() {
            try {
                // Инициализация Firebase
                if (!app) {
                    app = firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    // Firebase Auth is not strictly necessary for this Firestore-only anonymous access,
                    // but we can use an anonymous sign-in if needed for security rules.
                    // For simplicity, we rely on the security rules that allow writing.
                }

                // 1. Получение Telegram User ID и проверка на Админа
                if (isTMA && Telegram.WebApp.initDataUnsafe.user) {
                    const user = Telegram.WebApp.initDataUnsafe.user;
                    userTelegramId = user.id.toString();
                    userFirstName = user.first_name || user.username || 'Агитатор';

                    // 🔑 КОРРЕКТНАЯ ПРОВЕРКА НА АДМИНА
                    isAdmin = parseInt(userTelegramId) === ADMIN_ID;

                } else if (!isTMA) {
                    // Мок-данные для Web Preview
                    userTelegramId = ADMIN_ID.toString(); // Устанавливаем ID админа для тестового режима
                    userFirstName = 'Web Preview (Админ)';
                    isAdmin = true;
                    // Инициализация геолокации в Web Preview, чтобы было что показывать на карте
                    getLocation();
                }

                // 2. Отображение/скрытие админ-панели
                if (isAdmin) {
                    document.getElementById('adminPanel').classList.remove('hidden');
                    document.getElementById('reportsTab').classList.remove('hidden');
                } else {
                    document.getElementById('adminPanel').classList.add('hidden');
                    document.getElementById('reportsTab').classList.add('hidden');
                }

                return true;

            } catch (e) {
                console.error("Ошибка аутентификации или инициализации:", e);
                showAlert('Ошибка', 'Критическая ошибка инициализации Firebase/Telegram: ' + e.message, 'error');
                return false;
            }
        }


        // --- ИНИЦИАЛИЗАЦИЯ WEBAPP ---
        if (isTMA) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
            // Запрашиваем геолокацию сразу, если это TMA
            getLocation();
        }


        // 🔑 Инициализация при загрузке (Ожидаем authenticateUser)
        window.onload = async () => {
            // 0. Загружаем кэш (нужно до аутентификации)
            await loadCache();

            // 1. Сначала аутентификация для установки isAdmin и userTelegramId
            await authenticateUser();

            // 2. Затем заполнение интерфейса
            populateSettlements();
            // updateOfflineStatus() уже вызван в loadCache, но вызовем еще раз для гарантии
            updateOfflineStatus();
            window.showSection('form');
            lucide.createIcons();

            // ОТЛАДКА: Повторное обновление полей, чтобы гарантировать актуальность
            document.getElementById('debugUserId').textContent = userTelegramId || 'Нет ID';
            document.getElementById('debugUserName').textContent = userFirstName || 'N/A';
            document.getElementById('debugAdminStatus').textContent = isAdmin ? 'ДА' : 'НЕТ';

            if (!firebaseConfig.projectId) {
                window.showAlert('ВНИМАНИЕ', 'Необходимо вставить ключи конфигурации Firebase в код.');
            }
        };

        // Экспортируем функции для доступа из HTML
        window.authenticateUser = authenticateUser;
        window.fetchAndRenderReports = fetchAndRenderReports;
        window.renderLatestData = renderLatestData;
        window.generateMap = generateMap;
        window.submitForm = submitForm;
        window.syncData = syncData;
        window.clearCache = clearCache;
        window.confirmClearDatabase = confirmClearDatabase;
        window.clearDatabase = clearDatabase;
        window.showAlert = showAlert;

        // Включаем логирование (только для отладки)
        // firebase.firestore().setLogLevel('debug');

    </script>
</body>
</html>
