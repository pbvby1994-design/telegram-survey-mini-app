<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Блокнот Агитатора | v2.4 (Фикс Админа/Онлайн)</title>

    <!-- Tailwind CSS (для стилей) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons (для иконок) -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Chart.js (для графиков) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>

    <!-- Шрифт Jost -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jost:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Leaflet (для карт) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-heat/dist/leaflet-heat.js"></script>
    <!-- Leaflet Marker Cluster -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <style>
        :root {
            --primary-color: #0d9488; /* Teal-600 */
            --primary-light: #2dd4bf; /* Teal-400 */
            --secondary-color: #3b82f6; /* Blue-500 */
            --background-color: #f3f4f6; /* Gray-100 */
            --surface-color: #ffffff;
            --text-color: #1f2937; /* Gray-800 */
        }
        body {
            font-family: 'Jost', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 100%;
            padding: 16px;
        }
        .card {
            background-color: var(--surface-color);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid #e5e7eb;
        }
        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-primary:hover {
            background-color: #0f766e; /* Teal-700 */
        }
        .btn-secondary {
            background-color: #6b7280; /* Gray-500 */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-secondary:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        input[type="text"], input[type="number"], select, textarea {
            border: 1px solid #d1d5db; /* Gray-300 */
            border-radius: 6px;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            background-color: #f9fafb; /* Gray-50 */
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(13, 148, 136, 0.2);
            outline: none;
        }
        .form-group label {
            font-weight: 500;
            color: #374151; /* Gray-700 */
            margin-bottom: 4px;
            display: block;
        }
        /* Стили для вкладок */
        .tab-button {
            padding: 10px 16px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            color: #6b7280;
            transition: color 0.2s, border-color 0.2s;
        }
        .tab-button.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            font-weight: 600;
        }
        #map {
            height: 300px;
            width: 100%;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #e5e7eb;
        }
        /* Стили для модального окна */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        .modal-overlay.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: var(--surface-color);
            padding: 24px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -4px rgba(0, 0, 0, 0.2);
            transform: translateY(-20px);
            transition: transform 0.3s;
        }
        .modal-overlay.open .modal-content {
            transform: translateY(0);
        }
        .report-summary-card {
            grid-template-columns: 1fr;
        }
        @media (min-width: 640px) {
            .report-summary-card {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            }
        }
    </style>
</head>
<body class="min-h-screen">
    <div id="app-container" class="container mx-auto">
        <!-- Заголовок -->
        <h1 class="text-2xl font-bold text-center py-4 text-gray-800">Блокнот Агитатора</h1>

        <!-- Панель навигации/вкладок -->
        <div class="flex border-b border-gray-300 mb-4 bg-white rounded-t-lg shadow-sm">
            <button class="tab-button active flex-1" onclick="window.showSection('form')">
                <i data-lucide="send-horizontal" class="inline-block w-4 h-4 mr-2"></i> Отчет
            </button>
            <button class="tab-button flex-1" onclick="window.showSection('latest')" id="latest-data-tab">
                <i data-lucide="clipboard-list" class="inline-block w-4 h-4 mr-2"></i> Последние
            </button>
            <button class="tab-button flex-1" onclick="window.showSection('map-view')">
                <i data-lucide="map" class="inline-block w-4 h-4 mr-2"></i> Карта
            </button>
            <button class="tab-button flex-1 hidden" id="admin-tab" onclick="window.showSection('admin')">
                <i data-lucide="shield" class="inline-block w-4 h-4 mr-2"></i> Админ
            </button>
        </div>

        <!-- --- Секция "Отчет" (Форма ввода) --- -->
        <section id="form-section" class="active-section">
            <div class="card">
                <form id="report-form" onsubmit="window.saveReport(event)">
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <!-- Поселение -->
                        <div class="form-group">
                            <label for="settlement">Поселение:</label>
                            <select id="settlement" name="settlement" required>
                                <!-- Опции заполняются скриптом -->
                            </select>
                        </div>

                        <!-- ФИО -->
                        <div class="form-group">
                            <label for="name">ФИО жителя:</label>
                            <input type="text" id="name" name="name" placeholder="Иванов И.И." required>
                        </div>

                        <!-- Адрес -->
                        <div class="form-group">
                            <label for="address">Адрес:</label>
                            <input type="text" id="address" name="address" placeholder="ул. Ленина, д. 10" required>
                        </div>

                        <!-- Признак -->
                        <div class="form-group">
                            <label for="category">Признак:</label>
                            <select id="category" name="category" required>
                                <option value="" disabled selected>Выберите категорию</option>
                                <option value="За">За</option>
                                <option value="Против">Против</option>
                                <option value="Не_определился">Не определился</option>
                                <option value="Не_обнаружен">Не обнаружен</option>
                            </select>
                        </div>
                    </div>

                    <!-- Комментарий -->
                    <div class="form-group mt-4">
                        <label for="comment">Комментарий:</label>
                        <textarea id="comment" name="comment" rows="3" placeholder="Краткое описание проблемы, запроса, настроения..."></textarea>
                    </div>

                    <!-- Геолокация -->
                    <div class="form-group mt-4 flex items-center justify-between p-3 bg-gray-50 border border-gray-200 rounded-lg">
                        <div id="location-status" class="text-sm font-medium text-gray-700">
                            <i data-lucide="map-pin" class="inline-block w-4 h-4 mr-1 text-blue-500"></i> Геолокация: Не определена
                        </div>
                        <button type="button" onclick="window.getLocation()" class="flex items-center text-sm text-white bg-blue-500 hover:bg-blue-600 px-3 py-1.5 rounded-lg transition duration-150">
                            <i data-lucide="locate-fixed" class="w-4 h-4 mr-1"></i> Определить
                        </button>
                        <input type="hidden" id="latitude" name="latitude">
                        <input type="hidden" id="longitude" name="longitude">
                        <input type="hidden" id="accuracy" name="accuracy">
                    </div>

                    <!-- Фотография -->
                    <div class="form-group mt-4">
                        <label for="photo">Фотография (необязательно, только одна):</label>
                        <input type="file" id="photo" name="photo" accept="image/*" onchange="window.handlePhotoSelect(event)">
                        <div id="photo-preview" class="mt-2 text-sm text-gray-500"></div>
                    </div>

                    <!-- Кнопка отправки -->
                    <button type="submit" class="btn-primary w-full mt-6">
                        <i data-lucide="save" class="w-5 h-5 mr-2"></i> Отправить Отчет
                    </button>
                </form>
            </div>
            <!-- Статус кеша/онлайн -->
            <div id="offline-status" class="card p-3 text-sm flex items-center justify-between mt-4">
                <span class="text-gray-600">
                    <i data-lucide="cloud-off" class="w-4 h-4 mr-1 inline-block text-red-500"></i>
                    Офлайн-данные: <span id="offline-count" class="font-semibold">0</span>
                </span>
                <button onclick="window.syncData()" class="text-xs text-white bg-green-500 hover:bg-green-600 px-3 py-1.5 rounded-full transition duration-150">
                    <i data-lucide="rotate-ccw" class="w-3 h-3 mr-1 inline-block"></i> Синхронизировать
                </button>
            </div>

            <!-- Отладочная информация (скрыть в релизе) -->
            <div class="card p-3 text-xs text-gray-500 mt-4">
                <p>UserID: <span id="debugUserId"></span></p>
                <p>Админ: <span id="debugAdminStatus"></span></p>
            </div>

        </section>

        <!-- --- Секция "Последние данные" --- -->
        <section id="latest-section" class="hidden">
            <div class="card p-0 overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50 sticky top-0">
                        <tr>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Дата</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Адрес</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Признак</th>
                            <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Действия</th>
                        </tr>
                    </thead>
                    <tbody id="latest-data-body" class="bg-white divide-y divide-gray-200">
                        <!-- Данные будут вставлены сюда -->
                        <tr><td colspan="4" class="text-center py-4 text-gray-500">Нет последних данных.</td></tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- --- Секция "Карта" --- -->
        <section id="map-view-section" class="hidden">
            <div class="card">
                <div id="map" class="h-80 w-full mb-4"></div>
                <div class="flex space-x-2">
                    <button class="btn-primary flex-1 text-sm" onclick="window.generateMap('marker')">
                        <i data-lucide="map-pin" class="w-4 h-4 mr-1"></i> Маркеры
                    </button>
                    <button class="btn-secondary flex-1 text-sm" onclick="window.generateMap('cluster')">
                        <i data-lucide="layers" class="w-4 h-4 mr-1"></i> Кластеры
                    </button>
                    <button class="btn-secondary flex-1 text-sm" onclick="window.generateMap('heat')">
                        <i data-lucide="zap" class="w-4 h-4 mr-1"></i> Тепловая карта
                    </button>
                </div>
            </div>
        </section>


        <!-- --- Секция "Админ-панель" (Скрыта по умолчанию) --- -->
        <section id="admin-section" class="hidden">
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 text-gray-800 flex items-center">
                    <i data-lucide="shield-check" class="w-5 h-5 mr-2 text-primary-color"></i> Сводный Отчет
                </h2>

                <!-- Статистика -->
                <div id="report-summary" class="grid report-summary-card gap-3 mb-6">
                    <!-- Загружаются скриптом -->
                </div>

                <!-- График -->
                <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                    <h3 class="font-medium mb-3 text-gray-700">Отчет по Признакам</h3>
                    <div style="height: 250px;">
                        <canvas id="categoryChart"></canvas>
                    </div>
                </div>

                <!-- Список данных с фильтром -->
                <div class="mt-6">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">Все записи</h3>
                    <div class="flex space-x-2 mb-3">
                        <select id="admin-settlement-filter" class="flex-1" onchange="window.fetchAndRenderReports()">
                            <option value="">Все поселения</option>
                        </select>
                        <select id="admin-category-filter" class="flex-1" onchange="window.fetchAndRenderReports()">
                            <option value="">Все признаки</option>
                            <option value="За">За</option>
                            <option value="Против">Против</option>
                            <option value="Не_определился">Не определился</option>
                            <option value="Не_обнаружен">Не обнаружен</option>
                        </select>
                    </div>
                    <div class="p-0 overflow-x-auto border border-gray-200 rounded-lg">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-50 sticky top-0">
                                <tr>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Дата</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Поселение</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Адрес</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Признак</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Комм.</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ФИО</th>
                                    <th class="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Действ.</th>
                                </tr>
                            </thead>
                            <tbody id="admin-reports-body" class="bg-white divide-y divide-gray-200">
                                <tr><td colspan="7" class="text-center py-4 text-gray-500">Нажмите "Обновить" или измените фильтры.</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <button onclick="window.fetchAndRenderReports()" class="btn-secondary w-full mt-4">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2"></i> Обновить Отчет
                    </button>
                    <button onclick="window.confirmDeleteAll()" class="btn-secondary w-full mt-2 bg-red-500 hover:bg-red-600">
                        <i data-lucide="trash" class="w-4 h-4 mr-2"></i> Удалить Все Данные
                    </button>
                </div>
            </div>
        </section>


        <!-- --- Модальные окна --- -->

        <!-- Модальное окно "Сообщение" (Alert) -->
        <div id="alert-modal" class="modal-overlay" onclick="window.closeModal('alert')">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 id="alert-title" class="text-xl font-semibold mb-3 text-primary-color">Заголовок</h3>
                <p id="alert-message" class="text-gray-700 mb-4">Сообщение.</p>
                <div class="flex justify-end">
                    <button class="btn-primary px-4 py-2" onclick="window.closeModal('alert')">ОК</button>
                </div>
            </div>
        </div>

        <!-- Модальное окно "Подтверждение" (Confirm) -->
        <div id="confirm-modal" class="modal-overlay" onclick="window.closeModal('confirm')">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 id="confirm-title" class="text-xl font-semibold mb-3 text-red-500">Подтверждение</h3>
                <p id="confirm-message" class="text-gray-700 mb-4">Вы уверены?</p>
                <div class="flex justify-end space-x-3">
                    <button class="btn-secondary px-4 py-2" onclick="window.closeModal('confirm')">Отмена</button>
                    <button id="confirm-action-btn" class="btn-primary px-4 py-2 bg-red-500 hover:bg-red-600" data-action="">
                        Подтвердить
                    </button>
                </div>
            </div>
        </div>

        <!-- Модальное окно "Просмотр записи" (View Report) -->
        <div id="view-modal" class="modal-overlay" onclick="window.closeModal('view')">
            <div class="modal-content" onclick="event.stopPropagation()">
                <h3 class="text-xl font-semibold mb-3 text-primary-color">Детали Отчета</h3>
                <div id="view-details" class="space-y-3 text-gray-700 text-sm">
                    <!-- Заполняется скриптом -->
                </div>
                <div class="flex justify-end mt-4">
                    <button class="btn-primary px-4 py-2" onclick="window.closeModal('view')">Закрыть</button>
                </div>
            </div>
        </div>
    </div>


    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script type="module">
        // 🚨 ВАЖНО: Обновите ключи ниже для подключения к вашему проекту Firebase!

        // 📝 КОНФИГУРАЦИЯ FIREBASE (ЗАМЕНЕНА НА КЛЮЧИ ПОЛЬЗОВАТЕЛЯ)
        const firebaseConfig = {
            apiKey: "AIzaSyDVeRXO16KtIwoJQb4uHQuCsEv3xTLBGhI",
            authDomain: "agitator-notebook.firebaseapp.com",
            projectId: "agitator-notebook",
            storageBucket: "agitator-notebook.firebasestorage.app",
            messagingSenderId: "518555352011",
            appId: "1:518555352011:web:2b18d460a6fa4acb66944e",
            measurementId: "" // Можно оставить пустым
        };

        // 📦 Импорт Firebase (Обновлено до версии 12.4.0)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, where, getDocs, Timestamp, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-storage.js";

        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        const COLLECTION_NAME = "agitator_reports";
        const ADMIN_COLLECTION_NAME = "admins";
        const STORAGE_BUCKET_URL = `gs://${firebaseConfig.storageBucket}`;
        const isTMA = typeof Telegram !== 'undefined' && Telegram.WebApp;

        let app;
        let db;
        let auth;
        let storage;
        let userTelegramId = isTMA ? (Telegram.WebApp.initDataUnsafe.user?.id || null) : 'test-user-id';
        let isAdmin = false; // Будет обновлено в authenticateUser()
        let dataCache = JSON.parse(localStorage.getItem(COLLECTION_NAME) || '[]');
        let currentLatLng = null; // Для хранения последних координат

        try {
            if (firebaseConfig.projectId) {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                storage = getStorage(app);
                // Включаем логирование Firestore для отладки
                // setLogLevel('Debug');
            }
        } catch (e) {
            console.error("Firebase initialization failed:", e);
        }

        // --- СПИСОК ПОСЕЛЕНИЙ ---
        const SETTLEMENTS = [
            "Город А", "Село Б", "Деревня В", "Поселок Г"
        ];

        // --- УТИЛИТЫ UI/MODAL ---

        /**
         * Показывает модальное окно с сообщением.
         * @param {string} title Заголовок
         * @param {string} message Сообщение
         */
        window.showAlert = (title, message) => {
            document.getElementById('alert-title').textContent = title;
            document.getElementById('alert-message').textContent = message;
            document.getElementById('alert-modal').classList.add('open');
            if (isTMA) Telegram.WebApp.HapticFeedback.notificationOccurred('success');
        };

        /**
         * Показывает модальное окно для подтверждения действия.
         * @param {string} title Заголовок
         * @param {string} message Сообщение
         * @param {function} onConfirm Функция, которая будет вызвана при подтверждении
         */
        window.showConfirm = (title, message, onConfirm) => {
            document.getElementById('confirm-title').textContent = title;
            document.getElementById('confirm-message').textContent = message;
            document.getElementById('confirm-modal').classList.add('open');
            const confirmBtn = document.getElementById('confirm-action-btn');

            // Клонируем кнопку, чтобы удалить все предыдущие обработчики
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.onclick = async () => {
                window.closeModal('confirm');
                await onConfirm();
            };
            if (isTMA) Telegram.WebApp.HapticFeedback.notificationOccurred('warning');
        };

        /**
         * Закрывает модальное окно.
         * @param {'alert'|'confirm'|'view'} type Тип модального окна
         */
        window.closeModal = (type) => {
            document.getElementById(`${type}-modal`).classList.remove('open');
        };


        /**
         * Переключает активную секцию (вкладку).
         * @param {string} sectionId 'form', 'latest', 'map-view', 'admin'
         */
        window.showSection = (sectionId) => {
            const sections = ['form', 'latest', 'map-view', 'admin'];
            sections.forEach(id => {
                const section = document.getElementById(`${id}-section`);
                if (section) section.classList.add('hidden');
                document.querySelector(`.tab-button:nth-child(${sections.indexOf(id) + 1})`)?.classList.remove('active');
            });

            document.getElementById(`${sectionId}-section`)?.classList.remove('hidden');
            document.querySelector(`.tab-button:nth-child(${sections.indexOf(sectionId) + 1})`)?.classList.add('active');

            // Специальная логика для карты
            if (sectionId === 'map-view') {
                // Инициализируем или обновляем карту при переключении
                setTimeout(() => window.generateMap('marker'), 100);
            }
            if (sectionId === 'latest') {
                window.renderLatestData();
            }
            if (sectionId === 'admin') {
                window.fetchAndRenderReports();
            }
        };

        /**
         * Заполняет выпадающий список поселений.
         */
        const populateSettlements = () => {
            const selectForm = document.getElementById('settlement');
            const selectAdmin = document.getElementById('admin-settlement-filter');

            [selectForm, selectAdmin].forEach(select => {
                // Очищаем существующие опции, кроме первой (если есть)
                while (select.children.length > 1 && select.id !== 'settlement') {
                    select.removeChild(select.lastChild);
                }
                while (select.children.length > 0 && select.id === 'settlement') {
                     select.removeChild(select.lastChild);
                }

                if (select.id === 'admin-settlement-filter') {
                    const allOption = document.createElement('option');
                    allOption.value = "";
                    allOption.textContent = "Все поселения";
                    select.appendChild(allOption);
                } else if (select.id === 'settlement') {
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.textContent = "Выберите поселение";
                    defaultOption.disabled = true;
                    defaultOption.selected = true;
                    select.appendChild(defaultOption);
                }

                SETTLEMENTS.forEach(settlement => {
                    const option = document.createElement('option');
                    option.value = settlement;
                    option.textContent = settlement;
                    select.appendChild(option);
                });
            });
        };

        // --- АУТЕНТИФИКАЦИЯ & АДМИН ПРОВЕРКА ---

        /**
         * Выполняет анонимную аутентификацию в Firebase и проверяет статус администратора.
         */
        const authenticateUser = async () => {
            if (!auth) return;

            if (isTMA) {
                // 1. Попытка аутентификации через кастомный токен, если он доступен (не поддерживается в текущем фреймворке, используем анонимный вход)
                 // В реальном TMA, здесь нужно было бы использовать Telegram ID для получения кастомного токена от сервера.
                 // Для простоты Canvas/iframe, используем анонимный вход.
            }

            try {
                // Анонимный вход для всех пользователей
                await signInAnonymously(auth);
                // Обновляем userTelegramId на реальный UID из Firebase, если TMA не предоставил его
                userTelegramId = auth.currentUser?.uid || userTelegramId;

                // 2. Проверка статуса администратора
                if (userTelegramId) {
                    const adminDocRef = doc(db, ADMIN_COLLECTION_NAME, String(userTelegramId));
                    const adminDoc = await getDoc(adminDocRef);
                    isAdmin = adminDoc.exists();

                    if (isAdmin) {
                        document.getElementById('admin-tab').classList.remove('hidden');
                    }
                }
                console.log(`User authenticated. ID: ${userTelegramId}. Admin: ${isAdmin}`);

            } catch (error) {
                console.error("Authentication failed:", error);
                window.showAlert('Ошибка Аутентификации', 'Не удалось войти в Firebase. Проверьте конфигурацию и доступ.');
            }
        };

        // --- РАБОТА С ГЕОЛОКАЦИЕЙ И ФОТО ---

        /**
         * Получает текущую геолокацию.
         */
        window.getLocation = () => {
            const statusElement = document.getElementById('location-status');
            statusElement.innerHTML = '<i data-lucide="loader-circle" class="w-4 h-4 mr-1 inline-block animate-spin text-gray-500"></i> Геолокация: Определяем...';

            if (isTMA) Telegram.WebApp.HapticFeedback.impactOccurred('light');

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        currentLatLng = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude
                        };
                        document.getElementById('latitude').value = position.coords.latitude;
                        document.getElementById('longitude').value = position.coords.longitude;
                        document.getElementById('accuracy').value = position.coords.accuracy;

                        statusElement.innerHTML = `<i data-lucide="map-pin" class="w-4 h-4 mr-1 inline-block text-green-500"></i> Геолокация: Определена (${position.coords.latitude.toFixed(4)}, ${position.coords.longitude.toFixed(4)})`;
                        lucide.createIcons();
                        if (isTMA) Telegram.WebApp.HapticFeedback.notificationOccurred('success');
                    },
                    (error) => {
                        console.error("Geolocation error:", error);
                        currentLatLng = null;
                        document.getElementById('latitude').value = '';
                        document.getElementById('longitude').value = '';
                        document.getElementById('accuracy').value = '';
                        statusElement.innerHTML = '<i data-lucide="x-circle" class="w-4 h-4 mr-1 inline-block text-red-500"></i> Геолокация: Ошибка/Отказано';
                        lucide.createIcons();
                        if (isTMA) Telegram.WebApp.HapticFeedback.notificationOccurred('error');
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            } else {
                statusElement.innerHTML = '<i data-lucide="alert-triangle" class="w-4 h-4 mr-1 inline-block text-yellow-500"></i> Геолокация: Не поддерживается';
                lucide.createIcons();
            }
        };

        /**
         * Обрабатывает выбор файла фотографии и показывает превью.
         * @param {Event} event
         */
        window.handlePhotoSelect = (event) => {
            const file = event.target.files[0];
            const preview = document.getElementById('photo-preview');
            preview.innerHTML = '';
            if (file) {
                if (!file.type.startsWith('image/')) {
                    preview.textContent = 'Ошибка: Выбранный файл не является изображением.';
                    event.target.value = ''; // Сброс выбора
                    return;
                }
                if (file.size > 5 * 1024 * 1024) { // Ограничение 5MB
                    preview.textContent = 'Ошибка: Размер файла превышает 5MB.';
                    event.target.value = ''; // Сброс выбора
                    return;
                }

                const img = document.createElement('img');
                img.src = URL.createObjectURL(file);
                img.className = 'mt-2 max-h-40 rounded-lg object-cover border border-gray-200';
                preview.appendChild(img);
                preview.appendChild(document.createTextNode(` ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`));
            } else {
                preview.textContent = '';
            }
        };

        // --- РАБОТА С КЭШЕМ / ОФФЛАЙН ---

        /**
         * Обновляет счетчик офлайн-данных в интерфейсе.
         */
        const updateOfflineStatus = () => {
            document.getElementById('offline-count').textContent = dataCache.length;
            const statusCard = document.getElementById('offline-status');
            if (dataCache.length > 0) {
                statusCard.classList.remove('bg-gray-50');
                statusCard.classList.add('bg-yellow-100', 'border-yellow-400');
            } else {
                statusCard.classList.remove('bg-yellow-100', 'border-yellow-400');
                statusCard.classList.add('bg-gray-50');
            }
        };

        /**
         * Сохраняет отчет в локальный кеш.
         * @param {object} reportData Данные отчета
         */
        const saveToCache = (reportData) => {
            dataCache.push(reportData);
            localStorage.setItem(COLLECTION_NAME, JSON.stringify(dataCache));
            updateOfflineStatus();
        };

        /**
         * Синхронизирует офлайн-данные с Firebase.
         */
        window.syncData = async () => {
            if (!db || dataCache.length === 0) {
                if (dataCache.length === 0) window.showAlert('Синхронизация', 'Нет данных для синхронизации.');
                return;
            }

            if (isTMA) Telegram.WebApp.MainButton.showLoader();

            let successfulUploads = 0;
            const failedItems = [];
            const itemsToSync = [...dataCache]; // Копируем для итерации

            for (const item of itemsToSync) {
                try {
                    let photoUrl = '';
                    let photoRefPath = '';

                    // Если есть base64 фото, загружаем его в Storage
                    if (item.photoBase64 && item.photoName) {
                        const photoBlob = await (await fetch(item.photoBase64)).blob();
                        const photoStorageRef = ref(storage, `${COLLECTION_NAME}/${item.photoName}`);
                        await uploadBytes(photoStorageRef, photoBlob);
                        photoUrl = await getDownloadURL(photoStorageRef);
                        photoRefPath = photoStorageRef.fullPath;
                    }

                    const docData = {
                        ...item,
                        photoUrl: photoUrl,
                        photoRef: photoRefPath,
                        // Удаляем base64, чтобы не хранить его в Firestore
                        photoBase64: null,
                        // Добавляем метаданные синхронизации
                        createdAt: Timestamp.fromDate(new Date(item.createdAt)), // Восстанавливаем Timestamp
                        syncedAt: Timestamp.now(),
                        agitationUserId: userTelegramId
                    };

                    // Сохраняем документ в Firestore
                    await setDoc(doc(collection(db, COLLECTION_NAME)), docData);
                    successfulUploads++;

                    // Удаляем успешно синхронизированный элемент из локального кеша
                    dataCache = dataCache.filter(cachedItem => cachedItem !== item);
                } catch (e) {
                    console.error("Synchronization failed for an item:", e);
                    failedItems.push(item);
                }
            }

            localStorage.setItem(COLLECTION_NAME, JSON.stringify(dataCache));
            updateOfflineStatus();

            if (isTMA) Telegram.WebApp.MainButton.hideLoader();

            if (successfulUploads > 0) {
                window.showAlert('Успех!', `Синхронизировано ${successfulUploads} записей.`);
                // Обновляем последние данные, если находимся в соответствующей секции
                if (document.getElementById('latest-section').classList.contains('active-section')) {
                     window.renderLatestData();
                }
            } else if (failedItems.length > 0) {
                window.showAlert('Ошибка Синхронизации', `Не удалось синхронизировать ${failedItems.length} записей. Проверьте соединение.`);
            }
        };

        // --- РАБОТА С ФОРМОЙ И ОТЧЕТАМИ ---

        /**
         * Обработчик отправки формы.
         * @param {Event} event
         */
        window.saveReport = async (event) => {
            event.preventDefault();
            if (isTMA) Telegram.WebApp.MainButton.showLoader();

            const form = event.target;
            const data = new FormData(form);

            const reportData = {
                settlement: data.get('settlement'),
                name: data.get('name'),
                address: data.get('address'),
                category: data.get('category'),
                comment: data.get('comment'),
                latitude: parseFloat(data.get('latitude')) || null,
                longitude: parseFloat(data.get('longitude')) || null,
                accuracy: parseFloat(data.get('accuracy')) || null,
                createdAt: new Date().toISOString(), // Сохраняем в ISO-строке для кеша
                photoName: null,
                photoBase64: null
            };

            const photoFile = data.get('photo');

            if (photoFile && photoFile.size > 0) {
                const extension = photoFile.name.split('.').pop();
                const photoName = `${userTelegramId}_${Date.now()}.${extension}`;
                reportData.photoName = photoName;

                // Читаем файл в base64 для сохранения в кеш
                const reader = new FileReader();
                reader.onload = async (e) => {
                    reportData.photoBase64 = e.target.result;

                    // 1. Попытка отправки в Firebase
                    if (db) {
                         // Вначале попытаемся синхронизировать сразу, если онлайн
                        const success = await attemptDirectUpload(reportData, photoFile);
                        if (!success) {
                            // Если не удалось, сохраняем в кеш
                            saveToCache(reportData);
                            window.showAlert('Отчет сохранен', 'Отчет сохранен в офлайн-режиме и будет отправлен позже.');
                        }
                    } else {
                        // 2. Если Firebase не инициализирован, сохраняем в кеш
                        saveToCache(reportData);
                        window.showAlert('Отчет сохранен', 'Отчет сохранен в офлайн-режиме и будет отправлен позже.');
                    }

                    form.reset();
                    document.getElementById('location-status').innerHTML = '<i data-lucide="map-pin" class="w-4 h-4 mr-1 inline-block text-blue-500"></i> Геолокация: Не определена';
                    document.getElementById('photo-preview').innerHTML = '';
                    lucide.createIcons();
                    if (isTMA) Telegram.WebApp.MainButton.hideLoader();
                };
                reader.readAsDataURL(photoFile);
            } else {
                // Отчет без фото
                // 1. Попытка отправки в Firebase
                if (db) {
                     const success = await attemptDirectUpload(reportData);
                     if (!success) {
                        saveToCache(reportData);
                        window.showAlert('Отчет сохранен', 'Отчет сохранен в офлайн-режиме и будет отправлен позже.');
                     }
                } else {
                    // 2. Если Firebase не инициализирован, сохраняем в кеш
                    saveToCache(reportData);
                    window.showAlert('Отчет сохранен', 'Отчет сохранен в офлайн-режиме и будет отправлен позже.');
                }

                form.reset();
                document.getElementById('location-status').innerHTML = '<i data-lucide="map-pin" class="w-4 h-4 mr-1 inline-block text-blue-500"></i> Геолокация: Не определена';
                document.getElementById('photo-preview').innerHTML = '';
                lucide.createIcons();
                if (isTMA) Telegram.WebApp.MainButton.hideLoader();
            }
        };

        /**
         * Попытка прямой загрузки отчета в Firebase.
         * @param {object} reportData Данные отчета
         * @param {File} [photoFile] Файл фотографии (если есть)
         * @returns {boolean} true, если загрузка успешна, иначе false.
         */
        const attemptDirectUpload = async (reportData, photoFile = null) => {
            if (!db) return false;

            try {
                let photoUrl = '';
                let photoRefPath = '';

                // 1. Загрузка фото, если есть
                if (photoFile && reportData.photoName) {
                    const photoStorageRef = ref(storage, `${COLLECTION_NAME}/${reportData.photoName}`);
                    await uploadBytes(photoStorageRef, photoFile);
                    photoUrl = await getDownloadURL(photoStorageRef);
                    photoRefPath = photoStorageRef.fullPath;
                }

                // 2. Подготовка данных для Firestore
                const docData = {
                    ...reportData,
                    photoUrl: photoUrl,
                    photoRef: photoRefPath,
                    photoBase64: null, // Не сохраняем в Firestore
                    createdAt: Timestamp.now(), // Используем текущее время сервера
                    syncedAt: Timestamp.now(),
                    agitationUserId: userTelegramId
                };

                // 3. Сохранение документа
                await setDoc(doc(collection(db, COLLECTION_NAME)), docData);

                window.showAlert('Отчет отправлен!', 'Ваши данные успешно сохранены в Firebase.');
                window.renderLatestData(); // Обновляем список последних данных
                return true;

            } catch (e) {
                console.error("Direct upload failed:", e);
                return false;
            }
        };

        /**
         * Получает и отображает последние 10 записей пользователя.
         */
        window.renderLatestData = async () => {
            const tbody = document.getElementById('latest-data-body');
            tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-gray-500"><i data-lucide="loader-circle" class="w-5 h-5 mr-1 inline-block animate-spin"></i> Загрузка...</td></tr>';
            lucide.createIcons();

            if (!db) {
                tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-red-500 font-semibold">Firebase не инициализирован.</td></tr>';
                return;
            }

            try {
                // Запрос к Firestore: 10 последних записей текущего пользователя, отсортированных по дате
                const q = query(
                    collection(db, COLLECTION_NAME),
                    where('agitationUserId', '==', userTelegramId),
                    // Firestore не поддерживает orderBy без создания индексов, поэтому сортируем в JS.
                    // .orderBy('createdAt', 'desc'),
                    // .limit(10)
                );

                const querySnapshot = await getDocs(q);
                let reports = [];
                querySnapshot.forEach(doc => {
                    reports.push({ id: doc.id, ...doc.data() });
                });

                // Сортировка по дате в JS
                reports.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : new Date(a.createdAt).getTime();
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : new Date(b.createdAt).getTime();
                    return dateB - dateA; // Сортировка по убыванию
                });

                const latestReports = reports.slice(0, 10);

                if (latestReports.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-gray-500">Нет последних данных.</td></tr>';
                    return;
                }

                tbody.innerHTML = latestReports.map(report => {
                    const dateStr = report.createdAt?.toDate ? report.createdAt.toDate().toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' }) : new Date(report.createdAt).toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' });
                    const categoryClass = getCategoryColor(report.category);

                    return `
                        <tr class="hover:bg-gray-50 transition duration-150">
                            <td class="px-3 py-2 whitespace-nowrap text-xs text-gray-800">${dateStr}</td>
                            <td class="px-3 py-2 text-sm text-gray-800">${report.address}</td>
                            <td class="px-3 py-2 whitespace-nowrap">
                                <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${categoryClass}">
                                    ${report.category.replace(/_/g, ' ')}
                                </span>
                            </td>
                            <td class="px-3 py-2 whitespace-nowrap text-right text-sm font-medium">
                                <button onclick="window.viewReport('${report.id}')" class="text-indigo-600 hover:text-indigo-900 mx-1">
                                    <i data-lucide="eye" class="w-4 h-4 inline-block"></i>
                                </button>
                                <button onclick="window.confirmDelete('${report.id}', 'single')" class="text-red-600 hover:text-red-900 mx-1">
                                    <i data-lucide="trash-2" class="w-4 h-4 inline-block"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                }).join('');
                lucide.createIcons();

            } catch (e) {
                console.error("Error rendering latest data:", e);
                tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-red-500">Ошибка загрузки данных.</td></tr>';
            }
        };

        /**
         * Получает класс цвета для категории.
         * @param {string} category
         * @returns {string} Tailwind CSS классы
         */
        const getCategoryColor = (category) => {
            switch (category) {
                case 'За': return 'bg-green-100 text-green-800';
                case 'Против': return 'bg-red-100 text-red-800';
                case 'Не_определился': return 'bg-yellow-100 text-yellow-800';
                case 'Не_обнаружен': return 'bg-gray-100 text-gray-800';
                default: return 'bg-blue-100 text-blue-800';
            }
        };

        /**
         * Показывает модальное окно с деталями отчета.
         * @param {string} docId ID документа
         */
        window.viewReport = async (docId) => {
            if (!db) return;

            try {
                const docRef = doc(db, COLLECTION_NAME, docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const dateStr = data.createdAt?.toDate ? data.createdAt.toDate().toLocaleString('ru-RU', { dateStyle: 'full', timeStyle: 'short' }) : new Date(data.createdAt).toLocaleString('ru-RU', { dateStyle: 'full', timeStyle: 'short' });
                    const detailsDiv = document.getElementById('view-details');

                    let photoHtml = '';
                    if (data.photoUrl) {
                        photoHtml = `<img src="${data.photoUrl}" alt="Фотография" class="mt-2 max-h-48 w-full object-contain rounded-lg border border-gray-200" onerror="this.onerror=null; this.src='https://placehold.co/200x150/f3f4f6/374151?text=Нет+Фото';" />`;
                    }

                    detailsDiv.innerHTML = `
                        <p><strong>Дата/Время:</strong> ${dateStr}</p>
                        <p><strong>Поселение:</strong> ${data.settlement}</p>
                        <p><strong>ФИО:</strong> ${data.name}</p>
                        <p><strong>Адрес:</strong> ${data.address}</p>
                        <p><strong>Признак:</strong> <span class="px-2 inline-flex text-sm leading-5 font-semibold rounded-full ${getCategoryColor(data.category)}">${data.category.replace(/_/g, ' ')}</span></p>
                        <p><strong>Комментарий:</strong> ${data.comment || '—'}</p>
                        <p><strong>Координаты:</strong> ${data.latitude ? `${data.latitude.toFixed(4)}, ${data.longitude.toFixed(4)}` : 'Не указаны'}</p>
                        ${photoHtml}
                        <p class="text-xs text-gray-500 mt-2">ID пользователя: ${data.agitationUserId}</p>
                        <p class="text-xs text-gray-500">ID записи: ${docId}</p>
                    `;
                    lucide.createIcons();
                    document.getElementById('view-modal').classList.add('open');
                } else {
                    window.showAlert('Ошибка', 'Запись не найдена.');
                }
            } catch (e) {
                console.error("Error viewing report:", e);
                window.showAlert('Ошибка', 'Не удалось загрузить детали отчета.');
            }
        };

        /**
         * Запрашивает подтверждение для удаления.
         * @param {string} id ID документа или 'all'
         * @param {'single'|'all'} type Тип удаления
         */
        window.confirmDelete = (id, type) => {
            if (type === 'single') {
                window.showConfirm(
                    'Удаление Записи',
                    'Вы уверены, что хотите безвозвратно удалить эту запись?',
                    () => window.deleteReport(id)
                );
            }
        };

        /**
         * Запрашивает подтверждение для удаления всей коллекции.
         */
        window.confirmDeleteAll = () => {
            window.showConfirm(
                'УДАЛЕНИЕ ВСЕЙ БАЗЫ ДАННЫХ',
                'ВНИМАНИЕ! Это действие безвозвратно удалит ВСЕ записи из базы данных. Вы уверены?',
                () => window.deleteAllReports()
            );
        };


        /**
         * Удаляет отдельную запись и фото.
         * @param {string} docId ID документа
         */
        window.deleteReport = async (docId) => {
            if (!db) return;
            if (isTMA) Telegram.WebApp.MainButton.showLoader();

            try {
                // 1. Получаем данные для удаления фото
                const docRef = doc(db, COLLECTION_NAME, docId);
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();

                    // 2. Удаляем фото из Storage (если есть)
                    if (data.photoRef && storage) {
                        const photoRef = ref(storage, data.photoRef);
                        await deleteObject(photoRef).catch(e => {
                            // Логируем ошибку, но не прерываем удаление документа
                            console.warn("Could not delete photo from Storage:", e);
                        });
                    }

                    // 3. Удаляем документ из Firestore
                    await deleteDoc(docRef);

                    window.showAlert('Успешно!', 'Запись удалена.');
                    window.renderLatestData(); // Обновляем список
                    if (isAdmin) window.fetchAndRenderReports();
                } else {
                    window.showAlert('Ошибка', 'Запись не найдена в базе данных.');
                }
            } catch (e) {
                console.error("Error deleting report:", e);
                window.showAlert('Ошибка', 'Произошла ошибка при удалении записи: ' + e.message);
            } finally {
                if (isTMA) Telegram.WebApp.MainButton.hideLoader();
            }
        };


        // --- АДМИНСКИЕ ФУНКЦИИ ---

        /**
         * Получает и рендерит все отчеты для Админ-панели, а также статистику.
         */
        window.fetchAndRenderReports = async () => {
            if (!isAdmin || !db) return;

            const tbody = document.getElementById('admin-reports-body');
            tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500"><i data-lucide="loader-circle" class="w-5 h-5 mr-1 inline-block animate-spin"></i> Загрузка всех данных...</td></tr>';
            lucide.createIcons();

            try {
                // Получаем фильтры
                const settlementFilter = document.getElementById('admin-settlement-filter').value;
                const categoryFilter = document.getElementById('admin-category-filter').value;

                let q = collection(db, COLLECTION_NAME);
                let queryConstraints = [];

                if (settlementFilter) {
                    queryConstraints.push(where('settlement', '==', settlementFilter));
                }
                if (categoryFilter) {
                    queryConstraints.push(where('category', '==', categoryFilter));
                }

                // ВАЖНО: Firestore не поддерживает сложные запросы (AND) без индексов,
                // поэтому применяем фильтры в JS, если их больше 1.
                if (queryConstraints.length > 1) {
                    // Выполняем базовый запрос, затем фильтруем в JS
                    if (settlementFilter) {
                        q = query(collection(db, COLLECTION_NAME), where('settlement', '==', settlementFilter));
                    } else if (categoryFilter) {
                        q = query(collection(db, COLLECTION_NAME), where('category', '==', categoryFilter));
                    } else {
                        q = collection(db, COLLECTION_NAME);
                    }
                } else if (queryConstraints.length === 1) {
                    q = query(collection(db, COLLECTION_NAME), queryConstraints[0]);
                }


                const querySnapshot = await getDocs(q);
                let reports = [];
                let stats = { За: 0, Против: 0, Не_определился: 0, Не_обнаружен: 0, total: 0 };

                querySnapshot.forEach(doc => {
                    const data = { id: doc.id, ...doc.data() };

                    // Применяем второй фильтр (если их было два)
                    if (queryConstraints.length > 1) {
                        let shouldInclude = true;
                        if (settlementFilter && data.settlement !== settlementFilter) shouldInclude = false;
                        if (categoryFilter && data.category !== categoryFilter) shouldInclude = false;

                        if (!shouldInclude) return;
                    }


                    reports.push(data);
                    stats[data.category] = (stats[data.category] || 0) + 1;
                    stats.total++;
                });

                // Сортировка по дате в JS
                reports.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : new Date(a.createdAt).getTime();
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : new Date(b.createdAt).getTime();
                    return dateB - dateA; // Сортировка по убыванию
                });


                // Рендеринг статистики
                renderSummary(stats);

                // Рендеринг таблицы
                if (reports.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-gray-500">Нет записей по заданным фильтрам.</td></tr>';
                } else {
                    tbody.innerHTML = reports.map(report => {
                        const dateStr = report.createdAt?.toDate ? report.createdAt.toDate().toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' }) : new Date(report.createdAt).toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' });
                        const categoryClass = getCategoryColor(report.category);

                        return `
                            <tr class="hover:bg-gray-50 transition duration-150">
                                <td class="px-3 py-2 whitespace-nowrap text-xs text-gray-800">${dateStr}</td>
                                <td class="px-3 py-2 text-sm text-gray-800">${report.settlement}</td>
                                <td class="px-3 py-2 text-sm text-gray-800">${report.address}</td>
                                <td class="px-3 py-2 whitespace-nowrap">
                                    <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${categoryClass}">
                                        ${report.category.replace(/_/g, ' ')}
                                    </span>
                                </td>
                                <td class="px-3 py-2 text-xs text-gray-500 truncate max-w-xs">${report.comment || '—'}</td>
                                <td class="px-3 py-2 text-sm text-gray-800">${report.name}</td>
                                <td class="px-3 py-2 whitespace-nowrap text-right text-sm font-medium">
                                    <button onclick="window.viewReport('${report.id}')" class="text-indigo-600 hover:text-indigo-900 mx-1">
                                        <i data-lucide="eye" class="w-4 h-4 inline-block"></i>
                                    </button>
                                    <button onclick="window.deleteReport('${report.id}')" class="text-red-600 hover:text-red-900 mx-1">
                                        <i data-lucide="trash-2" class="w-4 h-4 inline-block"></i>
                                    </button>
                                </td>
                            </tr>
                        `;
                    }).join('');
                }

                lucide.createIcons();

            } catch (e) {
                console.error("Error fetching admin reports:", e);
                tbody.innerHTML = '<tr><td colspan="7" class="text-center py-4 text-red-500">Ошибка загрузки отчетов администратора.</td></tr>';
            }
        };

        let categoryChartInstance = null;
        /**
         * Рендерит сводную статистику и график.
         * @param {object} stats Объект статистики
         */
        const renderSummary = (stats) => {
            const summaryDiv = document.getElementById('report-summary');
            const total = stats.total;

            const summaryHtml = Object.keys(stats).filter(key => key !== 'total').map(key => {
                const count = stats[key];
                const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
                const color = {
                    'За': 'text-green-600',
                    'Против': 'text-red-600',
                    'Не_определился': 'text-yellow-600',
                    'Не_обнаружен': 'text-gray-600'
                }[key] || 'text-blue-600';

                return `
                    <div class="card p-4 border border-gray-200">
                        <p class="text-sm font-medium text-gray-500">${key.replace(/_/g, ' ')}</p>
                        <p class="text-2xl font-bold ${color}">${count}</p>
                        <p class="text-xs text-gray-400">${percentage}%</p>
                    </div>
                `;
            }).join('');

            // Добавляем карточку "Всего"
            const totalCard = `
                <div class="card p-4 border border-primary-light bg-primary-light/10">
                    <p class="text-sm font-medium text-gray-700">Всего Записей</p>
                    <p class="text-2xl font-bold text-primary-color">${total}</p>
                    <p class="text-xs text-transparent">.</p>
                </div>
            `;
            summaryDiv.innerHTML = totalCard + summaryHtml;

            // Рендеринг графика
            const ctx = document.getElementById('categoryChart').getContext('2d');
            if (categoryChartInstance) {
                categoryChartInstance.destroy();
            }

            const dataKeys = ['За', 'Против', 'Не_определился', 'Не_обнаружен'];
            const dataValues = dataKeys.map(key => stats[key] || 0);

            categoryChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: dataKeys.map(k => k.replace(/_/g, ' ')),
                    datasets: [{
                        data: dataValues,
                        backgroundColor: ['#047857', '#dc2626', '#fbbf24', '#9ca3af'], // Green, Red, Yellow, Gray
                        hoverBackgroundColor: ['#059669', '#ef4444', '#f59e0b', '#d1d5db']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });
        };

        /**
         * Удаляет всю коллекцию отчетов.
         */
        window.deleteAllReports = async () => {
            if (!isAdmin || !db) return;
            if (isTMA) Telegram.WebApp.MainButton.showLoader();

            try {
                const collectionRef = collection(db, COLLECTION_NAME);
                const querySnapshot = await getDocs(collectionRef);
                let deletedCount = 0;
                let photoRefs = [];
                const batch = writeBatch(db);

                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.photoRef) {
                        photoRefs.push(data.photoRef);
                    }
                    batch.delete(doc.ref);
                    deletedCount++;
                });

                if (deletedCount > 0) {
                    await batch.commit();

                    // Удаляем фотографии из Storage
                    if (storage) {
                        for (const photoRefPath of photoRefs) {
                            const photoRef = ref(storage, photoRefPath);
                            await deleteObject(photoRef).catch(e => console.warn("Could not delete photo from Storage during cleanup:", e));
                        }
                    }
                }

                document.getElementById('admin-reports-body').innerHTML = '<tr><td colspan="7" class="text-center py-4 text-red-500 font-semibold">База данных очищена.</td></tr>';

                // Очистка локального кеша
                dataCache = [];
                localStorage.removeItem(COLLECTION_NAME);
                updateOfflineStatus();
                showAlert('Успешно!', `Удалено ${deletedCount} записей. Данные Firestore очищены.`);

                if (isAdmin) fetchAndRenderReports();

                return true;

            } catch (e) {
                 console.error("Error deleting collection:", e);
                 showAlert('Ошибка', 'Произошла ошибка при удалении коллекции: ' + e.message);
                 return false;
            } finally {
                 if (isTMA) Telegram.WebApp.MainButton.hideLoader();
            }
        };

        // --- РАБОТА С КАРТОЙ ---

        let mapInstance = null;
        let markersGroup = null; // Для маркеров
        let heatLayerInstance = null; // Для тепловой карты

        /**
         * Инициализирует или обновляет карту с выбранным типом отображения.
         * @param {'marker'|'cluster'|'heat'} type Тип карты
         */
        window.generateMap = async (type) => {
            if (!db) return;

            // Сбор всех отчетов для карты
            let reports = [];
            try {
                const q = collection(db, COLLECTION_NAME);
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.latitude && data.longitude) {
                        reports.push(data);
                    }
                });
            } catch (e) {
                console.error("Error fetching map data:", e);
                return;
            }

            // --- Инициализация карты ---
            if (!mapInstance) {
                // Если нет отчетов, центрируем на России
                const initialLat = reports.length > 0 ? reports[0].latitude : 55.7558;
                const initialLng = reports.length > 0 ? reports[0].longitude : 37.6176;

                mapInstance = L.map('map').setView([initialLat, initialLng], 7);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 18,
                    attribution: '© OpenStreetMap contributors'
                }).addTo(mapInstance);
            }

            // --- Очистка предыдущих слоев ---
            if (markersGroup) mapInstance.removeLayer(markersGroup);
            if (heatLayerInstance) mapInstance.removeLayer(heatLayerInstance);

            // --- Рендеринг нового слоя ---
            if (type === 'marker' || type === 'cluster') {
                markersGroup = type === 'cluster' ? L.markerClusterGroup() : L.layerGroup();

                reports.forEach(report => {
                    const color = {
                        'За': 'green',
                        'Против': 'red',
                        'Не_определился': 'orange',
                        'Не_обнаружен': 'gray'
                    }[report.category] || 'blue';

                    const iconHtml = `<div style="background-color:${color}; width: 1.5rem; height: 1.5rem; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 0 2px black;"></div>`;
                    const customIcon = L.divIcon({
                        className: 'custom-div-icon',
                        html: iconHtml,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });

                    const dateStr = report.createdAt?.toDate ? report.createdAt.toDate().toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' }) : new Date(report.createdAt).toLocaleString('ru-RU', { timeStyle: 'short', dateStyle: 'short' });
                    const popupContent = `
                        <strong>${report.settlement}</strong><br>
                        ${report.address}<br>
                        Признак: <b>${report.category.replace(/_/g, ' ')}</b><br>
                        <small>${dateStr}</small>
                    `;

                    const marker = L.marker([report.latitude, report.longitude], { icon: customIcon })
                        .bindPopup(popupContent);

                    markersGroup.addLayer(marker);
                });

                mapInstance.addLayer(markersGroup);
                if (reports.length > 0) {
                     // Вычисляем границы для центрирования
                    const bounds = reports.map(r => [r.latitude, r.longitude]);
                    mapInstance.fitBounds(bounds, { padding: [20, 20] });
                }

            } else if (type === 'heat') {
                const heatData = reports.map(report => [report.latitude, report.longitude, 1]); // 1 - вес
                heatLayerInstance = L.heatLayer(heatData, { radius: 25, maxZoom: 14 }).addTo(mapInstance);
                if (reports.length > 0) {
                    const bounds = reports.map(r => [r.latitude, r.longitude]);
                    mapInstance.fitBounds(bounds, { padding: [20, 20] });
                }
            }

            // Обновляем кнопки
            document.querySelectorAll('#map-view-section button').forEach(btn => btn.classList.remove('btn-primary'));
            const activeBtn = document.querySelector(`#map-view-section button[onclick="window.generateMap('${type}')"]`);
            if (activeBtn) activeBtn.classList.add('btn-primary');
        };

        // --- ИНИЦИАЛИЗАЦИЯ WEBAPP ---
        if (isTMA) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
        }

        // 🔑 Инициализация при загрузке (Ожидаем authenticateUser)
        window.onload = async () => {
            // 1. Сначала аутентификация для установки isAdmin и userTelegramId
            await authenticateUser();

            // 2. Затем заполнение интерфейса
            populateSettlements();
            updateOfflineStatus();
            window.showSection('form');
            lucide.createIcons();

            // ОТЛАДКА: Повторное обновление полей, чтобы гарантировать актуальность
            document.getElementById('debugUserId').textContent = userTelegramId || 'Нет ID';
            document.getElementById('debugAdminStatus').textContent = isAdmin ? 'ДА' : 'НЕТ';

            if (!firebaseConfig.projectId) {
                window.showAlert('ВНИМАНИЕ', 'Необходимо вставить ключи конфигурации Firebase в код.');
            }
        };

        // Экспортируем функции для доступа из HTML
        window.authenticateUser = authenticateUser;
        window.fetchAndRenderReports = fetchAndRenderReports;
        window.renderLatestData = renderLatestData;
        window.generateMap = generateMap;
    </script>
</body>
</html>
